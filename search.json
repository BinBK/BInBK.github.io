[{"title":"node接口","url":"/2022/09/11/node接口/","content":"\n\n> Node.js对一些特殊用例进行优化，提供替代的[API](https://baike.baidu.com/item/API/10154?fromModule=lemma_inlink)，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的[网络应用](https://baike.baidu.com/item/网络应用/2196523?fromModule=lemma_inlink)。\n\n<!--more-->\n## 创建\n\n1. 通过 npm init 创建 package.json文件\n2. 通过npm install express 安装express模块\n3. 创建app.js写入以下代码\n4. node app.js 启动\n\n```js\n//导入\nconst express = require('express')\n//创建\nconst app = express()\n\napp.get('/user',(req,res) => {\n    res.send({ name:'zs', age: 20, gender:'男' })\n})\napp.post('/user',(req,res) => {\n    res.send('请求成功');\n})\n\n\n//启动\napp.listen(80,() => {\n    console.log('express server running at http://127.0.0.1');\n})\n\n```\n\n## Express中间件\n\n中间件函数的形参中，必须包含next参数。而路由处理函数中只包含req和res\n\n```js\nconst express = require('express')\n\nconst app = express()\n\nconst mw = function(req,res,next){\n\n    console.log('中间件被调用');\n    next()\n}\n\napp.listen(80,() => {\n    console.log('http://127.0.0.1');\n})\n\n\n\napp.use((req,res,next){\n\tconsole.log('中间件')\n\tnext()\n})\n//中间件的作用可以在上游中间件统一为req或res对象添加自定义属性或方法，供下游的中间件或路由使用\n\n\nconst express = require(\"express\");\n\nconst app = express()\n\napp.use((req,res,next) => {\n    const timeNow = Date.now()\n    req.Nowtime = timeNow\n    next()\n})\n\napp.get('/',function(req,res){\n    res.send('Home page' + req.Nowtime)\n})\n\napp.get('/user',(req,res) => {\n    res.send('User page' + req.Nowtime)\n})\n\napp.listen(80,()=>{\n    console.log('http://127.0.0.1');\n})\n\n\n\n```\n\n### 解析请求数据\n\n```js\n//json\nconst express = require(\"express\");\n\nconst app = express()\n\napp.use(express.json())\n\n//通过express.urlencoded()解析表单 url-encoded格式的数据\napp.use(express.urlencoded({extenden:false}))\n\napp.post('/user',(req,res)=>{\n    //req.body来接收客户端发送过来的请求体数据\n    console.log(req.body);\n    res.send('ok')\n})\n\n```\n\n### CORS跨域资源共享\n\nnpm install cors\n\n//在路由之前配置cors解决跨域\n\n```js\nconst cors = require('cors')\napp.use(cors())\n```\n\n\n1、作用\n\ncors由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否组织前端JS代码跨域获取资源\n\n浏览器的同源安全策略默认会阻止网页\"跨域\"获取资源。\n\n主要在服务器端进行配置，客户端无需做任何额外配置\n\n2、cors响应头部\n\n响应头部中可携带Access-Control-Allow-Origin字段\n\nAccess-Control-Allow-Origin: <origin> | *\n//其中origin参数的值指定了允许访问该资源的外域URL,通配符*表示任何域\n\n例如\n\nres.SetHeader('Access-Control-Allow-Origin','https://lnkjzm.cn')\n\n默认情况CORS只支持客户端发起GET、POST、HEAD请求，若使用其他方式：\n\nres.SetHeader('Access-Control-Allow-Methods','POST,GET,DELETE,HEAD')\n\n3、简单请求和预检请求\n\n简单请求：客户端与服务器之间只发生一次请求\n\n预检请求：客户端与服务器之间发生两次请求，OPTION预检请求成功之后才会发生真正请求\n\n","tags":["node"],"categories":["node"]},{"title":"uni-app 生命周期","url":"/2022/08/07/uni-app-生命周期/","content":"生命周期概念：一个对象从创建、运行、销毁的整个过程被称为生命周期\n\n生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数\n<!--more-->\n\n## 应用的生命周期\n\n| 函数名   | 说明                                        |\n| -------- | ------------------------------------------- |\n| onLaunch | 当uni-app初始化完成是触发（全局只触发一次） |\n| onShow   | 当uni-app启动，或从后台进入前台显示         |\n| onHide   | 当uni-app从前台进入后台                     |\n| onError  | 当uni-app报错时触发                         |\n\n## 页面的生命周期\n\n| 函数名   | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| onLoad   | 监听页面加载，其参数为上个页面传递的数据，参数类型为Object(用于页面传承) |\n| onShow   | 监听页面显示，页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |\n| onReady  | 监听页面初次渲染完成                                         |\n| onHide   | 监听页面隐藏                                                 |\n| onUnload | 监听页面卸载                                                 |\n\n## 组件的生命周期\n\n| 函数名        | 说明                                                         | 平台         |\n| ------------- | ------------------------------------------------------------ | ------------ |\n| beforeCreate  | 在实例初始化之后被调用                                       |              |\n| created       | 在实例创建完成后被立刻调用                                   |              |\n| beforeMount   | 在挂载开始之前被调用                                         |              |\n| mounted       | 挂载到实例上去之后调用                                       |              |\n| beforeUpdate  | 数据更新时调用，发生在虚拟DOM打补丁之前                      | 仅H5平台支持 |\n| updated       | 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子 | 仅H5平台支持 |\n| beforeDestroy | 实例销毁之前使用                                             |              |\n| destroyed     | Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 |              |\n\n\n\n\n\n\n\n","tags":["uni-app"],"categories":["uni-app"]},{"title":"Ant Design","url":"/2022/07/29/Ant-Design/","content":"> `antd` 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品\n>\n> [Ant Design]([Ant Design - 一套企业级 UI 设计语言和 React 组件库 (antgroup.com)](https://ant-design.antgroup.com/index-cn))\n\n## 按需加载\n\n```\nnpm add @craco/craco\n```\n<!--more-->\n修改package.json中关于scripts中的配置\n\n```\n\"scripts\": {\n    \"start\": \"craco start\",\n    \"build\": \"craco build\",\n    \"test\": \"craco test\",\n    \"eject\": \"react-scripts eject\"\n  },\n```\n\n初始化babel\n\n```\nnpm install babel-plugin-import\n```\n\n在根目录新建craco.config.js文件\n\n```\nmodule.exports = {\n    babel: {//支持装饰器\n        plugins: [\n            [\n                \"import\",\n                {\n                    \"libraryName\": \"antd\",\n                    \"libraryDirectory\": \"es\",\n                    \"style\": 'css' //设置为true即是less 这里用的是css\n                }\n            ]\n        ]\n    },\n};\n```\n\n使用\n\n```\nimport { Button } from 'antd';\n<Button type=\"primary\">Primary Button</Button>\n```\n\n","tags":["React"],"categories":["React"]},{"title":"React hooks","url":"/2022/07/21/React-hooks/","content":"\n> *Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。[官方文档]([Hooks FAQ – React (docschina.org)](https://react.docschina.org/docs/hooks-faq.html))\n\nReact有类组件和函数组件。两种组件最明显的不同在于语法上，函数组件是一个纯函数，它接收一个props对象返回一个react元素。而类组件需要去继承React.Component并且创建render函数返回react元素，需要更多的代码，但实现的效果相同。需要注意的是，在函数组件中不能使用生命周期钩子。\n\n<!--more-->\nReact Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。\n\n这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。\n\n## useState\n\n在函数组件中，可以使用`useState`来定义函数组件的状态。使用`useState`来创建状态\n\n- 1.引入\n- 2.接收一个参数作为初始值\n- 3.返回一个数组，第一个值为状态，第二个值为改变状态的函数\n\n```jsx\nimport React,{ useState } from 'react'\n\nconst [name, setName] = useState('小明')\n //     类名，修改函数名            初始值\n```\n\n## useEffect\n\n`useEffect`又称副作用`hooks`。作用：给没有生命周期的组件，添加结束渲染的信号。执行时机：在渲染结束之后执行\n\n- 什么是副作用？\n  - 副作用 ( side effect ): 数据获取，数据订阅，以及手动更改 React 组件中的 DOM 都属于副作用\n  - 因为我们渲染出的页面都是静态的，任何在其之后的操作都会对他产生影响，所以称之为副作用\n- 使用：\n  - 1.第一个参数，接收一个函数作为参数\n  - 2.第二个参数，接收【依赖列表】，只有依赖更新时，才会执行函数\n  - 3.返回一个函数，先执行返回函数，再执行参数函数\n\n如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用`useEffect`的回调函数。\n\n```jsx\nimport { useEffect } from 'react'\n\nuseEffect( () => {\n     console.log('Hello World!!')\n},[])\n```\n\n## useContext\n\n`useContext`是让子组件之间共享父组件传入的状态的\n\n- 需要引入`useContetx`，`createContext`两个内容\n- 通过`createContext`创建一个context句柄\n- `Context.Provider`来确定数据共享范围\n- 通过`value`来分发内容\n- 在子组件中，通过`useContext(Context句柄)`来获取数据\n- **注意**上层数据发生改变，肯定会触发重新渲染（点击`button`按钮触发父组件更新传入的`num`值能看到子组件重新渲染）\n\n```jsx\nconst Context = createContext(null)  \nfunction StateFunction () {  \n    const [num, setNum] = useState(1)  \n    return (  \n        <div>  \n            <button onClick={ ()=> setNum(num => num+1) }>增加num的值+1</button>  \n            <br></br>  \n            这是一个函数式组件——num:{  num }  \n            <Context.Provider value={num}>  \n                <Item3></Item3>  \n                <Item4></Item4>  \n            </Context.Provider>  \n        </div>  \n    )  \n}  \nfunction Item3 () {  \n    const num = useContext(Context)  \n    return (  \n        <div>  \n            子组件3: { num }  \n        </div>  \n    )  \n}  \nfunction Item4 () {  \n    const num = useContext(Context)  \n    return (  \n        <div>  \n            子组件4: { num+2 }  \n        </div>  \n    )  \n}  \n```\n\n\n\n","tags":["React"],"categories":["React"]},{"title":"Vue组件","url":"/2022/07/17/Vue组件/","content":"组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。vue组件是把页面（html代码，CSS代码）进行模块化。\n\n当一个界面的功能很复杂时，可以变成多个组件来实现页面。\n\n作用是复用编码，简化项目编码，提高运行效率。\n\nVueCompoent简称vc,vc是组件的实例对象，vm是Vue的实例对象，vm管理vc。有多个vc，但vm是唯一的，只有一个el。\n\n## 使用组件\n\n在vue脚手架中使用组件的步骤有三步，定义组件，注册组件，使用组件\n\n<!--more-->\n```\n//About.vue\n<template>\n  <div class=\"about\">\n    <h1>这是组件</h1>\n  </div>\n</template>\n\n\n<template>\n  <div id=\"app\">\n    //使用组件\n    \n    <HelloWorld />\n  </div>\n</template>\n\n<script>\n//引入\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nexport default {\n  el:\"#app\",\n  //注册组件\n  components: {\n    HelloWorld\n  }\n}\n</script>\n\n```\n\n## 组件间数据通信\n\n### 1.子组件访问父组件数据\n\n在调用子组件时，绑定想要获取的父组件中的数据在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据。即父组件通过props向下传递数据给子组件。\n注：组件中的数据存在方式共有三种：data、props、computed\n\nprops传递数据两种形式\n\n数组方式： props:['msg', 'username', 'age', 'userObj']\n对象方式：该方式提供了对数据的校验、类型监测、默认值设置操作。\n\n在vue脚手架中，父传子\n\n```\n//父组件\n<father :bookList=\"bookList\"/>\n//子组件\nprops:{\n\tbookList:{\n\t\ttype:String,//类型\n\t\trequired: true //必要性\n\t}\n}\n\n```\n\n### 2.父组件访问子组件的数据（子传父）\n\n    第一步：在子组件中使用 vm.$emit(事件名,数据) 触发一个自定义事件，事件名自定义。\n    \n    第二步：父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据。 \n    \n    总结：子组件通过events（事件）给父组件发送消息，实际上就是子组件把自己的数据发送到父组件\n    \n     <!DOCTYPE html>\n    <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>父组件访问子组件的数据（子传父）</title>\n            <script src=\"../js/vue.js\"></script>\n        </head>\n        <body>\n            <div id=\"app\">\n                <h2>{{info}}</h2>\n                <!--使用局部子组件-->\n                <!--@itemClick绑定自定义的子组件itemClick事件到父组件到回调方法上-->\n                <component-a @item-click=\"parentClick\"></component-a>\n            </div>\n        </body>\n        <template id=\"myTemplate\">\n            <div>\n                <!--根据分类展示多个按钮, 当点击按钮会调用方法btnClick并把每一类的对象传进去-->\n                <input type=\"button\" v-for=\"item in categories\" v-bind:value=\"item.name\" @click=\"btnClick(item)\">\n            </div>\n        </template>\n        <script>\n            //定义组件\n            let componentA = {\n                template: `#myTemplate`,\n                data() {\n                    return {\n                        //分类\n                        categories: [\n                            {id: 1, name: \"电脑\"},\n                            {id: 2, name: \"衣帽\"},\n                            {id: 3, name: \"零食\"},\n                            {id: 4, name: \"生鲜\"}\n                        ],\n                    }\n                },\n                methods: {\n                    btnClick(item) {\n                        //触发自定义的事件, 同时把item事件传进去\n                        //$emit(\"自定义的事件名称\", 数据) 触发自定义的事件\n                        //自定义事件的名称, 全部小写字母或短横线, 不能使用驼峰, 因为html不区分大小写\n                        this.$emit(\"item-click\", item);\n                    }\n                }\n            };\n            let vm = new Vue({\n                el: \"#app\",\n                data() {\n                    return {\n                        info: \"哈哈\",\n                    }\n                },\n                //注册组件\n                components: {\n                    \"component-a\": componentA,\n                },\n                methods: {\n                    //父组件的回调函数, 接收参数(参数是子组件触发自定义事件传进来的)\n                    parentClick(item) {\n                        this.info = `子组件点击了按钮, 父组件收到子组件数据id为:${item.id},name为:${item.name}`;\n                    }\n                }\n            })\n        </script>\n    </html>\n\n### 3.非父子通信\n\n创建一个Vue实例作为中央事件总线，通过它来监听($on)和触发($emit)事件。适用于组件间全部通信方式。\n\n```js\n//实例Vue实例作为中央事件总线\nvar Event=new Vue();\n//发送事件\nEvent.$emit(事件名,数据);\n//监听事件\nEvent.$on(事件名,data => {});\n```\n\n\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"axios常用请求","url":"/2022/07/12/axios常用请求/","content":"## axios常见4种请求方法\n\n**1、get请求**\n\n用于获取数据。\n\n```js\n \t//写法一\n\tcurrentPage是传进来的参数\n            axios.get(''/Bookf/'+currentPage+'/5'', {\n                params: {\n                    id: 12,//请求参数\n                },\n            }).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'get',//请求方法\n                params: {\n                    id: 12,//请求参数\n                },\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n<!--more-->\n**2、post请求**\n\n用于提交数据（新建）、包括表单提交及文件上传。\n\n```js\n\t\t //写法一\n            let data={\n                id:12\n            }\n            axios.post('接口地址', data}).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'post',//请求方法\n                data: data,\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n\n**3、put请求**\n\n用于更新数据（修改），将所有数据都推送到后端。\n\n```js\n\t\t\t//写法一\n            let data = {\n                id:12\n            }\n            axios.put('接口地址', data}).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'put',//请求方法\n                data: data,\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n\n**4、delete请求**\n\n用于删除数据。\n\n```js\n  \t\t\t//写法一\n            let data = {\n                id:12\n            }\n            //url传递参数\n            axios.delete('接口地址', {\n                parmas:{\n                    id:12\n                }\n            }).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //post方式传递参数\n            axios.delete('接口地址', {\n                data:{\n                    id:12\n                }\n            }).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'patch',//请求方法\n                parmas:{\n                    id:12\n                },\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n\n\n\n### 全局使用axios\n\n注意vue3中没有vue.prototype,使用需要使用别的方法写默认端口\n\n```\nVue3\n\nimport axios from 'axios'\nconst app = createApp(App)\napp.config.globalProperties.$axx=axios\naxios.defaults.baseURL='/api'\n\napp.use(store).use(router).mount('#app')\n------------------------------------\nVue2\nimport axios from 'axios'\nVue.prototype.$axios = axios\naxios.defaults.baseURL='/api'\n```\n\n# ","tags":["axios"],"categories":["axios"]},{"title":"Postman","url":"/2022/07/12/Postman/","content":"## 什么是Postman\n\nPostman是接口测试工具，可用来测试接口是否可用，能不能正常使用，方便前端对接接口\n\n> Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。软件功能非常强大，界面简洁明晰、操作方便快捷，设计得很人性化。Postman中文版能够发送任何类型的HTTP 请求 (GET, HEAD, POST, PUT…)，附带任何数量的参数+ headers。\n>\n> 从可视化界面直接输入要访问的url+参数，就可以获取从后台返回前端的数据，可以以json,xml等多种格式直观的展示出来，尤其对前后端分离的项目有非常好的调试作用。\n\n<!--more-->\n\n## 使用\n\n常用于CRUD，也就是增删查改，选择要发送的请求，输入要访问的路径参数即可。需要注意的，像POST请求是用json传输的，所以不能使用一般的传参，需要在Body里选择raw里的JSON，再编写自己需要上传的数据，如下图所示\n\n从可视化界面直接输入要访问的url+参数，就可以获取从后台返回前端的数据，可以以json,xml等多种格式直观的展示出来，尤其对前后端分离的项目有非常好的调试作用\n![image](Postman/image-20220720013718809.png)\n","tags":["测试工具"],"categories":["测试工具"]},{"title":"节流和防抖","url":"/2022/07/10/节流和防抖/","content":"防抖是用户频繁操作，但只执行一次。节流是变少量操作\n\n为应对web页面中频繁触发事件，出现节流和防抖两种优化方案。\n\n**防抖**：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\n **节流**：高频事件触发，但在n秒内只会执行一次，节流会稀释函数的执行频率\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。\n\n<!--more-->\n\n```js\n/*函数节流*/\n\nfunction throttle(fn, interval) {\n\n  var enterTime = 0;//触发的时间\n\n  var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\n\n  return function() {\n\n    var context = this;\n\n    var backTime = new Date();//第一次函数return即触发的时间\n\n    if (backTime - enterTime > gapTime) {\n\n      fn.call(context,arguments);\n\n      enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\n\n    }\n\n  };\n\n}\n\n/*函数防抖*/\n\nfunction debounce(fn, interval) {\n\n  var timer;\n\n  var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\n\n  return function() {\n\n    clearTimeout(timer);\n\n    var context = this;\n\n    var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\n\n    timer = setTimeout(function() {\n\n      fn.call(context,args);\n\n    }, gapTime);\n\n  };\n\n}\n\n\n```\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"路由守卫","url":"/2022/06/27/路由守卫/","content":"\nVue路由守卫是对路由进行权限控制，比如想要用户登录了才能访问页面。分三类，全局守卫、独享守卫、组件内守卫。编写的地方不一样。\n\n1.全局 \n\n​\tbeforeEach、beforeResolve、afterEach\n\n2.路由独享\n\n​\tbeforeEnter\n<!--more-->\n\n3.组件内\n\n​\tbeforeRouteEnter、beforeRouteUpdate、beforeRouteLeave\n\n### 实际应用\n\n```js\nrouter.beforeEach((to, from, next) => {\n  NProgress.start(); // NProgress实现显示加载进度条效果\n  console.log(\"routemgr to\", to.path);\n  if (\"这里判断是不是开发环境\") {\n    //开发环境下，直接路由\n    next();\n  } else {\n    if (to.path == \"/login\") {\n      //登录页面\n      session.set(\"isOpen\", \"ok\");\n      next();\n    } else if (\"这里判断如不是生产环境下录页面需要判断权限\") {\n      //非生产环境下\n      next();\n    } else {\n      //非登录页面需要判断权限\n      console.log(\"routemgr user\", lu.userinfo);\n      if (gadget.isEmptyObject(lu.userinfo)) {\n        //首次打开页面的时候，不需要弹出错误页面提示，直接跳转至登录页面即可\n        let ret = session.get(\"isOpen\");\n        if (ret == \"ok\") {\n          //vuex用户信息判断，如果不存在，则重新登录\n          MessageBox.alert(\"用户未登录,需要重新登录.\", \"错误\", {\n            confirmButtonText: \"确定\",\n            type: \"error\",\n          }).then(() => {\n            console.log(\"重新登录\");\n            //next(`/procmgr/login?redirect=${to.path}`);\n            next(`/login`);\n            NProgress.done();\n          });\n        } else {\n          next(`/login`);\n          NProgress.done();\n        }\n      } else {\n        //权限判断\n      }\n    }\n  }\n});\n\n```\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"localStorage、sessionStorage和cookie","url":"/2022/06/21/localStorage、sessionStorage和cookie/","content":"\n##  一、localStorage\n\nlocalStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的UI 上清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。\n\n## 二、sessionStorage\n\nsessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除。存 放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持。\n<!--more-->\n## 三、cookie\n\n\n\n### 优点\n\n具有极高的扩展性和可用性\n\n1. 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。\n2. 通过加密和安全传输技术，减少 cookie 被破解的可能性。\n3. 只有在 cookie 中存放不敏感的数据，即使被盗取也不会有很大的损失。\n4. 控制 cookie 的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就是一个过期的 cookie。\n\n### 缺点\n\n1.cookie 的长度和数量的限制。每个 domain 最多只能有 20 条 cookie，每个cookie 长度不能超过 4KB。\n否则会被截掉。\n2.安全性问题。如果 cookie 被人拦掉了，那个人就可以获取到所有 session 信息。加密的话也不起什么\n作用。\n3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若\n\n吧计数器保存在客户端，则起不到什么作用。\n\n4.`http请求` 时需要发送到服务端，增加了请求的数据量\n\n## 共同点\n\nlocalStorage、sessionStorage、Cookie 都是保存在浏览器端，且同源的\n\n## 区别\n\n1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 \n2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 \n3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 \n4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 \n5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 \n6、web Storage的api接口使用更方便\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"箭头函数和普通函数","url":"/2022/06/18/箭头函数和普通函数/","content":"\n## 一、箭头函数中this的指向不同\n\n箭头函数的this指向上层函数作用域的this对象，如果没有上层函数作用域，则指向顶部this（在浏览器中顶部this则是window）。普通函数的this指向该函数的调用者。\n  call, apply, bind会改变普通函数的this，但不会改变箭头函数的this\n\n```\nvar name = \"this1\";\nfunction wrap(){\n  this.name=\"this2\";\n  let func=() => {\n    console.log(this.name);\n  }\n  func();\n}\nlet en=new wrap();\n\n```\n\n<!--more-->\n\n## 二、外形不同\n\n箭头函数使用箭头定义，普通函数中没有\n\n```\n// 普通函数\nfunction func(){\n  // code\n}\n// 箭头函数\nlet func=()=>{\n  // code\n}\n\n```\n\n## 三、箭头函数都是匿名函数\n\n普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。\n\n```\n// 具名函数\nfunction func(){\n  // code\n}\n \n// 匿名函数\nlet func=function(){\n  // code\n}\n\n// 箭头函数全都是匿名函数\nlet func=()=>{\n  // code\n}\n\n```\n\n## 四、箭头函数不能用于构造函数，不能使用new\n\n普通函数可以用于构造函数，以此创建对象实例。\n\n```\nfunction Person(name,age){\n   this.name=name;\n   this.age=age;\n}\nlet admin=new Person(\"栤bong\",18);\nconsole.log(admin.name); //栤bong\nconsole.log(admin.age);  //18\n\n```\n\n## 五、其他区别\n\n- 普通函数的参数是arguments,而箭头函数的的是args\n- 箭头函数不具有prototype原型对象\n- 箭头函数不具有super\n- 箭头函数不具有new.target","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Vue路由","url":"/2022/06/16/Vue路由/","content":"\n## Vue路由\n\n路由模式有两种：history、hash，区别有以下：\n\n1.表现形式不同 \n\n​\thistory：http://localhost:8080/about\n\n​\thash：http://localhost:8080/#/about\n\n2.跳转请求\n\n​\thistory：http://localhost:8080/id ==>发送请求\n\n​\thash：不会发送请求\n<!--more-->\n\n3.打包后前端自测要使用hash，如果使用history会出现空白页面\n\n### Vue路由跳转\n\n1.声明式导航 ，在router-link中进行跳转\n\n2.编程式导航，通过点击事件，利用push/replace，可编写业务代码\n\n### 嵌套路由\n\n在路由内写children，继续创建路由\n\n```\n{\n    path: '/Notes',\n    name: 'Notes',\n    redirect: '/Notes/newFile',\n    component: function () {\n      return import('../views/noteMain.vue')\n    },\n    children: [\n      {\n        path: \"/Notes/newFile\",\n        name: \"myNotes\",\n        component: function () {\n          return import('@/components/newFile.vue')\n        }\n      }\n    ]\n  }\n```\n\n\n\n## Vue路径传值\n\nvue路径传值有两种，在网页路径显示参数的显式传值和不显示的隐式传值\n\n```\n1.显式\n\t传：this.$router.push({\n\t\tpath:'/about',\n\t\tquery:{\n\t\t\ta:1\n\t\t}\n\t})\n\t接： this.$route.query.a\n2.隐式\n\t传： this.$router.push({\n\t\tname:'About',\n\t\tparams:{\n\t\t\ta:1\n\t\t}\n\t})\n\t接：this.$route.params.a\n```\n\n# ","tags":["Vue"],"categories":["Vue"]},{"title":"原型和原型链","url":"/2022/06/13/原型和原型链/","content":"\n## 原型\n\n**原型**就是存储方法或属性的对象，可以解决对象共享属性和共享方法,。函数才有prototype属性。\n\n**prototype(原型)：**prototype是Function对象的一个属性，它定义了构造函数制造出的对象的公用祖先（属性和方法），可以继承该原型的属性和方法。原型也是对象。\n\n**__proto__（隐式原型）：**没个对象的__proto__属性指向自身构造函数的prototype。\n\n**constructor（构造器）：**返回对创建此对象的数组函数引用。\n<!--more-->\n## 原型链\n\n原型链是一种机制，指的是js中，每个对象都有一个属性__proto__，指向它的构造函数的原型对象。原型对象也是一个对象，因此也有__proto__属性指向原型对象的原型对象，这样一层层向上直到对象的原型对象为空（Object的原型对象Object.prototpye的属性__proto__为null）。\n\n原型链就是把原型串联起来，实现对象间的联系即继承的方法。\n\n可通过下面例子查看它们之间的关系\n\n```javascript\n\t\t\tfunction Person(){}\n\t\t\tvar p = new Person();\n\t\t\tconsole.log(p.__proto__)//打印出一个对象\n\t\t\tconsole.log(p.__proto__.constructor)//构造函数本身\n\t\t\tconsole.log(Person.prototype)\n\t\t\tconsole.log(Person.prototype.constructor)\n\t\t\tconsole.log(p.__proto__===Person.prototype)\n\t\t\tconsole.log(p.__proto__.constructor===Person.prototype.constructor)\n\t\t\t\n```\n\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Vue生命周期","url":"/2022/06/11/Vue生命周期/","content":"\n## 生命周期是什么？\n\n Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，称这是 Vue 的生命周期。\n\n## 各个生命周期作用\n<!--more-->\n\n| 生命周期      | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                       |\n| created       | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 |\n| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用           |\n| mounted       | el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子    |\n| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前              |\n| update        | 组件数据更新之后                                             |\n| activited     | keep-alive 专属，组件被激活时调用                            |\n| deactivated   | keep-alive 专属，组件被销毁时调用                            |\n| beforeDestory | 组件销毁前调用                                               |\n\n\n\n## keep-alive\n\nkeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ,有以下特性：\n\n1. 一般结合路由和动态组件一起使用，用于缓存组件\n2. 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 \n3. 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"闭包","url":"/2022/06/08/闭包/","content":"\n闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。\n\n## 闭包的用途\n\n​\t闭包最大的用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用后被自动清除。\n\n​\t在页面中写多个li标签，使用下面代码，点击li标签可知是第几个li标签\n<!--more-->\n\n```javascript\nvar lis = document.getElementsByTagName('li');\n\t\tfor(var i=0;i<lis.length;i++){\n\t\t\t(function(i){\n\t\t\t\tlis[i].onclick=function(){\n\t\t\t\t\talert(i);\n\t\t\t\t}\n\t\t\t})(i)\n\t\t}\t\n```\n\n## 闭包的缺陷\n\n​\t闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或变为null。\n\n```\nvar lis = document.getElementsByTagName('li');\n\t\tfor(var i=0;i<lis.length;i++){\n\t\t\t(function(i){\n\t\t\t\tlis[i].onclick=function(){\n\t\t\t\t\talert(i);\n\t\t\t\t}\n\t\t\t\t//手动清空变量\n\t\t\t\tlis[i]=null;\n\t\t\t})(i)\n\t\t}\n```\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"mysql","url":"/2022/04/11/mysql/","content":"## 数据库\n\nMySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。\n<!--more-->\n\n### 关系型数据库\n\n关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织\n\n#### 优点：\n\n1、易于维护：都是使用表结构，格式一致；\n2、使用方便：SQL语言通用，可用于复杂查询；\n3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。\n\n#### 缺点：\n\n1、读写性能比较差，尤其是海量数据的高效率读写；\n2、固定的表结构，灵活度稍欠；\n3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。\n\n\n### 非关系型数据库\n\n非关系型数据库(NoSQL)严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。\n\n#### 优点：\n\n1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。\n2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；\n3、高扩展性；\n4、成本低：nosql数据库部署简单，基本都是开源软件。\n\n#### 缺点：\n\n1、不提供sql支持，学习和使用成本较高；\n2、无事务处理；\n3、数据结构相对复杂，复杂查询方面稍欠。\n\n\n\n## 使用\n\n### 标准SQL语句\n\n 常见的操作有查询，新增，更新，删除，求和，排序等。\n\n查询语句：SELECT param FROM table WHERE condition 该语句可以理解为从 table 中查询出满足 condition 条件的字段 param。\n\n新增语句：INSERT INTO table （param1，param2，param3） VALUES （value1，value2，value3） 该语句可以理解为向table中的param1，param2，param3字段中分别插入value1，value2，value3。\n\n更新语句：UPDATE table SET param=new_value WHERE condition 该语句可以理解为将满足condition条件的字段param更新为 new_value 值。\n\n删除语句：DELETE FROM table WHERE condition 该语句可以理解为将满足condition条件的数据全部删除。\n\n去重查询：SELECT DISTINCT param FROM table WHERE condition 该语句可以理解为从表table中查询出满足条件condition的字段param，但是param中重复的值只能出现一次。\n\n排序查询：SELECT param FROM table WHERE condition ORDER BY param1该语句可以理解为从表table 中查询出满足condition条件的param，并且要按照param1升序的顺序进行排序。\n\n\n\n```sql\nCREATE DATABASE `smbms`;\n\nDROP TABLE IF EXISTS `smbms_address`;\nCREATE TABLE `smbms_address`  (\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',\n  `contact` VARCHAR(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '联系人姓名',\n  `addressDesc` VARCHAR(50) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '收货地址明细',\n  `postCode` VARCHAR(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '邮编',\n  `tel` VARCHAR(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '联系人电话',\n  `createdBy` BIGINT(20) NULL DEFAULT NULL COMMENT '创建者',\n  `creationDate` DATETIME NULL DEFAULT NULL COMMENT '创建时间',\n  `modifyBy` BIGINT(20) NULL DEFAULT NULL COMMENT '修改者',\n  `modifyDate` DATETIME NULL DEFAULT NULL COMMENT '修改时间',\n  `userId` BIGINT(20) NULL DEFAULT NULL COMMENT '用户ID',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = INNODB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = DYNAMIC;\n\nINSERT INTO `smbms_address` VALUES (1, '王丽', '北京市东城区东交民巷44号', '100010', '13678789999', 1, '2016-04-13 00:00:00', NULL, NULL, 1);\n\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"正则表达式","url":"/2022/03/05/正则表达式/","content":"\n# 正则表达式\n\n## 简介\n\n> ​\t正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为**regex**、**regexp**或**RE**），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。\n> ​\t正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。\n\n## 常用元字符\n<!--more-->\n| 字符    | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| \\       | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\\\' 匹配 \"\\\" 而 \"\\(\" 则匹配 \"(\"。 |\n| ^       | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $       | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| *       | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| +       | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| ?       | 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 。? 等价于 {0,1}。 |\n| .       | 匹配除换行符以外的任意字符                                   |\n| \\w      | 匹配字母或数字或下划线                                       |\n| \\s      | 匹配任意的空白符                                             |\n| \\d      | 匹配数字                                                     |\n| \\W      | 匹配非字母或数字或下划线                                     |\n| \\D      | 匹配非数字                                                   |\n| \\S      | 匹配非空白符                                                 |\n| [...]   | 匹配字符组中的字符                                           |\n| [^...]  | 匹配除了字符组中字符的所有字符                               |\n| .*      | 贪婪匹配                                                     |\n| **.*?** | 惰性匹配                                                     |\n\n## 作用\n\n使用正则表达式在字符串中搜索需要的字符。判断字符串是否正则表达式的过滤逻辑（称作“匹配”），从而获取我们需要的部分。\n\n正则表达式的特点是灵活性、逻辑性和功能性强大，可以迅速、极简单的方式达到字符串的复杂控制。可用于搜索、python爬虫筛选需要的数据。\n\n[点击测试正则表达式](https://c.runoob.com/front-end/854/) \n\n","tags":["正则表达式"],"categories":["Github"]},{"title":"Vuex","url":"/2022/02/07/Vuex/","content":"## 什么是Vuex？\n\n> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式 + 库**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## 安装\n\n```\nnpm install vuex --save\n//使用\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n<!--more-->\n\n### promise\n\nVuex 依赖Promise。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如es6-promise。在vue3x中\n\n```\n//安装\nnpm install es6-promise --save \n//需要添加在使用Vuex之前\nimport 'es6-promise/auto'\n```\n\n## 核心概率\n\nVuex 的核心由五部分组成：State、Getter、Mutation、Action 和 Module，简单的 Vuex，也至少会由 State 和 Mutation 构成。\n\n### state\n\n### mapState辅助函数\n\n当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性\n\n### Getter\n\n有时候，我们会发现 State 中的数据，并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求，这时我们可以使用Getter\n\n### Mutation\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数\n\n### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 提交的是 mutation，而不是直接变更状态。\n- Action 可以包含任意**异步**操作。\n\n### Module\n\n这个是项目比较复杂时使用，一般很多使用\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割","tags":["Vuex"],"categories":["Vuex"]},{"title":"Element Plus","url":"/2022/02/06/Element-Plus/","content":"> 基于 Vue 3，面向设计师和开发者的组件库。\n>\n> element终于发布新版本了，这让我们使用Vue3的时候更方便，以下是两个element对于vue的使用方法\n\n## 一、Element UI\n\n[Element UI官网](https://element.eleme.io/#/zh-CN) \n\n如果是Vue 2.x搭建的项目，使用elementUI如下\n\n```\nvue add element\n```\n<!--more-->\n完整引入，在main.js下写\n\n```js\nimport Vue from 'vue';\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\nimport App from './App.vue';\n\nVue.use(ElementUI);\n\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n});\n```\n\n之后在组件里寻找需要的功能\n\n## 二、Element Plus\n\n[Element Plus官网](https://element-plus.gitee.io/zh-CN/)\n\n如果是Vue3.x使用这个，在搭建好的项目了，下载\n\n```\n npm install element-plus --save\n```\n\n### 使用\n\n在main.js中写\n\n```js\nimport { createApp } from 'vue'\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\napp.use(ElementPlus)\napp.mount('#app')\n```\n\n\n\n","tags":["Vue","Element"],"categories":["Vue","Element"]},{"title":"TCP/IP协议","url":"/2022/01/26/让div水平垂直居中11/","content":"\n# TCP/IP协议\n\n## 什么是TCP/IP协议\n\n> TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。\n>\n> 在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。计算机使用者意识到，只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。\n>\n> 但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了\n<!--more-->\n## IP\n\nIP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。\n\n通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。\n\n当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。\n\nIP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。\n\n在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。\n\n每个计算机必须有一个 IP 地址才能够连入因特网。每个 IP 包必须有一个地址才能够发送到另一台计算机。网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。\n\n## TCP\n\nTCP 用于应用程序之间的通信。\n\n当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。\n\n这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。\n\nUDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。\n\n### TCP三次握手\n\n所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。\n\n### TCP四次挥手\n\n所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，\n\n\n\n## TCP/IP\n\nTCP/IP 意味着 TCP 和 IP 在一起协同工作。\n\nTCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。\n\nIP 负责计算机之间的通信。\n\nTCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。\n\nIP 负责将包发送至接受者。\n\n### TCP/IP协议分层\n\nTCP/IP协议族按照层次由上到下，层层包装。\n\n可搜索OSI 七层模型和TCP/IP四层模型更能直观了解\n\n**应用层**:\n 向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。\n\n**传输层**:\n 提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。\n\n**网络层** ：\n 负责相邻计算机之间的通信。其功能包括三方面。\n 一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。\n\n二、处理输入数据报：首先检查其合法性，然后进行寻径--假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。\n\n三、处理路径、流控、拥塞等问题。\n\n**网络接口层**：\n 这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。","tags":["TCP/IP协议"],"categories":["TCP/IP协议"]},{"title":"Git","url":"/2022/01/25/Git/","content":"## 一、Git文件的三种状态和工作模式\n\n### 1.状态\n\n使用Git操作文件时，文件的三种状态\n\n|       状态        |                             描述                             |\n| :---------------: | :----------------------------------------------------------: |\n| 已提交(committed) |             表示数据已经安全的保存在本地数据库中             |\n| 已修改(modified)  |            表示修改了文件，但还没有保存到数据库中            |\n|  已暂存(staged)   | 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 |\n<!--more-->\n### 2.工作模式\n\nGit项目的三个工作区域\n\n|  分类   |                             描述                             |\n| :-----: | :----------------------------------------------------------: |\n| 工作区  |                      自己本地创建的项目                      |\n| 暂存区  | Git版本库里存着很多东西，其中最重要的是称为stage(或者叫index)的暂存区，还有Git自动创建的第一个分支master，以及指向master的一个指针叫HEAD |\n| Git仓库 |  工作区有一个隐藏目录.git,这个不算是工作区，而是Git的版本库  |\n\n基本的Git工作流程如下：\n\n- 在工作区中修改文件\n- 对修改的文件进行快照，然后添加到暂存区\n- 提交更新，将保存在暂存区域的文件快照永久转储到Git仓库中 \n\n## 二、创建版本库并提交文件\n\n```c\ngit init 初始化本地仓库\ngit status 查看状态\ngit add . 添加文件,<path>是文件也可以是目录\ngit commit -m '注释' 提交添加的文件并备注说明\ngit remote add origin xxx  xxx是远程仓库地址，连接远程仓库\ngit push -u origin master 将本地仓库文件推送到远程仓库\n```\n\n## 三、文件操作\n\n### 1、查看\n\n```c\ngit log 查看变更日志\ngit branch 查看分支\ngit reflog 查看之前的修改操作\ngit ls-files 查看暂存区文件 \ngit log -5 --pretty=oneline 查看最近五次修改操作\n```\n\n### 2、删除\n\n```c\ngit rm 文件名.后缀 工作区和本地仓库的文件都删除\ngit remote rm origin 删除远程仓库\n```\n\n### 3、文件恢复\n\n如果已经把文件提交到本地仓库，却不小心误删了\n\n```c\ngit checkout -- 文件名.后缀 如果已经把文件提交到本地仓库，不小心误删了，可以从本地仓库把文件恢复到工作区\n```\n\n## 四、版本回退\n\n```c\ngit reset --hard HEAD^    //回退多少个版本就多少个^,或者~1,回退多少个版本数字就写多少个，或者 -hard 版本号    \n```\n\n","tags":["Github","Git"],"categories":["Github","Git"]},{"title":"使用jsDeliver+Github建图床","url":"/2022/01/24/使用jsDeliver-Github建图床/","content":"## 一、介绍\n\n### 1.什么是jsDlive\n\n> jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。\n\n### 2.为什么使用图床\n\n> 图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。\n>\n> Github使用的是cdn加速\n\n我们写博客或网站时，会使用到图片，把图片放到本地的话，可能会出现问题，还会影响网页加载速度，使用图床能很好解决这些问题。\n<!--more-->\n\n## 二、使用Github创建仓库\n\n### 1.创建Github仓库\n\n找到Repositories,点击new，写入仓库名，注意仓库要公开的，选择Public，然后创建\n\n### 2.将图片推送到仓库\n\n在本地文件夹使用Git Bash，与创建的Github仓库连接，放入图片\n\n```c\ngit add * //*代表当前目录所有文件\ngit commit -m \"写要提交的信息\"\ngit push //推送到远程仓库\n```\n\n## 三、使用jsDelive加载图片\n\n根据格式写出来的链接相对于一个外链，直接使用即可\n\n```c\nhttps://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径\n\n//例\nhttps://cdn.jsdelivr.net/gh/BinBK/mycdn/images/background2.png\n```\n\n\n","tags":["Github","jsDlive"],"categories":["Github","jsDlive"]},{"title":"IDEA的使用","url":"/2022/01/23/123/","content":"## 导入项目时出现的问题\n\n没有运行按钮，查看文件颜色不正确为橙色。\n<!--more-->\n1. 检查maven，jdk版本是否对应\n2. 选择File→Project Structure→Modules，查看是否为本地地址，如果不是，在Add Content Root中把项目叉掉，再点击+，选择项目\n3. 如果pom.xml文件为橙色，右键–>add as maven projec，下载依赖\n\n## 运行web项目\n\n在锤子图案旁边的Add Configuration，点击+，选择Tomcat的local，配置本地Tomcat地址，在Deployment中选择需要运行的项目\n\n## 快捷键\n\nShift+F10 \t运行\n\nShift+回车\t不影响当行，跳到下行\n\nAlt+Shift+↓\t快速复制当行\n\nCtrl+R\t\t\t快速替换\n\nCtrl+F\t\t\t快速查找\n\nCtrl+Alt+左右键\t回到上次光标所在","tags":["IDEA"],"categories":["IDEA"]},{"title":"使用网易云api","url":"/2021/10/28/使用网易云api/","content":"\n## 网址\n\n[网易云音乐 API](https://binaryify.github.io/NeteaseCloudMusicApi/#/)\n\n### 安装使用\n\n上面网址有说明\n先安装 他的东西，再加入他的文件夹 npm install\n再运行即可\n\n[参考](https://blog.csdn.net/lin13958756858/article/details/90906286)\n"},{"title":"axios使用","url":"/2021/10/19/axios使用/","content":"\n## axios\n\n### 直接使用\n\n一、\n安装 axios\nnpm install --save axios\n二、\n导入 axios\nimport axios from 'axios'\n三、使用\n<!--more-->\n\n\n```js\nmounted(){\nthis.$axios.get(\"网址\")\n.then(res => {\nconsole.log(res.data);\n})\n.catch(error =>{\nconsole.log(error);\n})\n}\n```\n\n### 跨域\n\n一、\n安装\n二、使用到的文件\nmain.js\nvue.config.js\napp.vue\n三、\n\n##### main.js\n```js\nimport axios from 'axios'\n\nVue.prototype.$axios = axios;\n```\n\n\n\n#### vue.config.js\n```js\nmodule.exports = {\ndevServer: {\nproxy: {\n'/te': {\n// 此处的写法，目的是为了 将 /api 替换成 https://www.baidu.com/\ntarget: 'http://apis.juhe.cn',\n// 允许跨域\nchangeOrigin: true,\nws: true,\npathRewrite: {\n'^/te': ''\n}\n}\n}\n}\n}\n\n```\n\n#### app.vue\n\n和上面一样，改前面的地址\n\n[跨域参考一](https://www.cnblogs.com/l-y-h/p/11815452.html)\n[中文文档](https://www.kancloud.cn/yunye/axios/234845)\n\n[可以直接连接的网络接口](http://www.iwenwiki.com/)\n\nq:\n拦截器，开发环境和生产环境怎么区分\n","tags":["axios"],"categories":["axios"]},{"title":"查看端口某个端口是否被占用","url":"/2021/10/15/查看端口某个端口是否被占用/","content":"\n> 启动应用时不能运行，有可能时要使用的端口被别的程序占用，但又不知道被谁占用，那我们就需要找出是什么程序并关闭\n<!-- more -->\n## 一、查找占用端口的PID\n\n打开cmd命令行窗口，输入命令：**netstat -ano**,就可以列出使用使用中的端口，可以看到以下显示，在本地地址中最后一串数字就是我们想要的端口，在这里查看是否被占用\n\n![image-端口展示](https://cdn.jsdelivr.net/gh/BinBK/myCdn/images/PID211015a.png)\n\n查看被占用端口对应的PID，输入命令：netstat -aon|findstr “数值”，输入端口可查到相关使用信息，输入PID可看到相关端口\n\n## 二、根据PID找到相关程序\n\n继续输入**tasklist|findstr** \"PID数值\"，查看是哪个进程或者程序占用了端口\n\n## 三、关闭相关程序\n\n打开任务管理器，找到相关程序并关闭\n![image-任务管理器](https://cdn.jsdelivr.net/gh/BinBK/myCdn/images/PID211015b.png)","tags":["计算机"],"categories":["计算机"]},{"title":"hexo加入图片","url":"/2021/10/14/hexo简单介绍/","content":"\n## 加入图片\n\n### 下载插件\n\n一、\nnpm install https://github.com/7ym0n/hexo-asset-image --save\n这是修改过的插件，因为版本问题用这个比较好\n二、\n配置\\_config.yml 里面的 post_asset_folder:false 这个选项设置为 true。\n<!--more-->\n三、\n\n使用\n![xxx](xxx/xxx.png)\n问题一：怎么解决让格式代码正常显示\n\n[具体网站](https://www.jianshu.com/p/3db6a61d3782)\n\n## 可参考博客\n\n[博客一](https://notes.iissnan.com/2015/something-about-next/)\n[博客二](http://51world.win/) 这个有点旧了，注意看时间\n\n## hexo 书写相关文章\n\n[网站一](https://www.jianshu.com/p/56d99a3049a5)\n","tags":["hexo"],"categories":["hexo"]},{"title":"让div水平垂直居中","url":"/2021/10/14/让div水平垂直居中/","content":"使用css让div盒子实现水平垂直居中的几种方法\n\n## 一、flex\n\n使用flex布局，在父元素上写，子元素将水平垂直居中\n\n```html\n#container{\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n}\n```\n<!--more-->\n\n\n## 二、使用定位\n\n准备\n\n```html\n<style type=\"text/css\">\n\nhtml,body{\n\theight:100%;  /*注意html不设置高度 body也就没有继承高度，就会随内容支撑高度*/\n\toverflow: hidden;  \n\tmargin:0;\n\tpadding: 0;\n}\n</style>\n\n```\n\n### 1.已知道宽高，绝对定位,margin减去div一半宽高\n\n```html\n#box{\n\tbackground: red;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\tmargin-left: -100px;\n\tmargin-top: -100px;\n}\n```\n\n### 2.div宽高未知，使用translate平移一半宽高\n\n```html\n#box {\n\tbackground: red;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\ttransform: translate(-50%,-50%);\n}\n```\n\n### 3.定位好，margin:auto\n\n```html\n#box {\n\tbackground: red;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\ttop: 0;\n\tbottom: 0;\n\tmargin: auto;\n}\n```\n\n","tags":["css"],"categories":["css"]},{"title":"Github的使用","url":"/2021/10/13/Github的使用/","content":"\n## 一、使用Github搜索项目\n\n> 最简单的是直接使用搜索框搜索项目，但这样搜索出来的项目多且乱，不知道使用那一个比较好，使用Github高级搜索语法能更快让我们找到想要的项目\n<!-- more -->\n### Github高级搜索语法\n\n#### 1.stars\n\n想要找到高质量的项目，可通过筛选star数找到多人收藏的。stars:>3000，直接在搜索的项目后面加空格写入即可找到star三千以上的项目。\n\n#### 2.pushed\n\n如果想找最近有更新的项目，可使用这个。pushed：>2022-1-1,即可找到2022年一月一号也后更新的项目\n\n#### 3.desciption\n\n搜索项目的简介。in:description 博客，即可找到简介有博客这个词的项目\n\n#### 4.language\n\n搜索项目的语言\n\n## 二、本地文件上传到Github仓库\n\n> 需要先配置SSH key。cd ~/. ssh #检查本机已存在的ssh密钥，如果提示：No such file or directory 说明你是第一次使用git，则需要配置。已经安装了node.js、npm、git\n\n在Repositories中新建一个仓库，在本地新建文件夹，点击进入后，打开Git Bash或cmd命名窗口\n\n初始化本地仓库\n\n```c\ngit init\n```\n\n将文件提交到暂存区, . 是选择所有文件\n\n```c\ngit add .\ngit commit -m \"写提交文件的说明\"\ngit branch -M main 第一次创建需要写\ngit remoted aa origin xxxx 写仓库的地址，第一次提交需要写\ngit push -u origin main\t提交到远程仓库    \n```\n\n## 三、将Github项目下载到本地\n\n有两个办法，一、直接下载压缩包，二、git clone 地址，下载到本地\n","tags":["Github"],"categories":["Github"]},{"title":"Hello World","url":"/2021/10/12/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]