[{"title":"数据库事务和索引","url":"/2024/06/26/数据库事务和索引/","content":"### 1. **数据库事务（Database Transaction）**\n\n#### **定义**：\n\n事务是一个或多个数据库操作的集合，这些操作要么全部执行成功，要么全部回滚，以确保数据的一致性和完整性。事务通常用于处理需要确保一致性的数据操作，例如金融转账等关键操作。\n<!--more-->\n#### **事务的ACID特性**：\n\n事务有四个关键的ACID特性，确保了事务的可靠性：\n\n1. **原子性（Atomicity）**：  \n   事务中的所有操作必须作为一个整体执行。如果事务中的任何一部分操作失败，则整个事务必须回滚，数据库状态应恢复到事务开始前的状态。\n\n2. **一致性（Consistency）**：  \n   事务执行前后，数据库的状态必须保持一致。这意味着事务操作不能违反数据库的完整性约束，如唯一性约束、外键约束等。\n\n3. **隔离性（Isolation）**：  \n   事务之间应相互独立，互不影响。一个事务的执行不能受到其他事务未提交操作的影响。不同的隔离级别决定了事务之间的相互影响程度（如读未提交、读已提交、可重复读、序列化等）。\n\n4. **持久性（Durability）**：  \n   一旦事务提交，事务的结果就必须永久保存，即使系统发生故障，事务的结果也不会丢失。\n\n#### **事务的生命周期**：\n\n- **开始事务**：通过 `BEGIN TRANSACTION` 或类似命令显式开启事务。\n- **执行操作**：执行插入、更新、删除等数据库操作。\n- **提交事务**：通过 `COMMIT` 提交事务，确保所有操作永久保存。\n- **回滚事务**：通过 `ROLLBACK` 回滚事务，将所有操作撤销，恢复到事务开始前的状态。\n\n#### **事务的应用场景**：\n\n- **银行转账**：转账操作通常涉及两个账户的更新，必须确保两个账户的更新要么都成功，要么都失败。\n- **订单处理**：处理订单时，如果某个步骤失败，如库存不足，整个订单处理过程应该回滚。\n\n### 2. **数据库索引（Database Index）**\n\n#### **定义**：\n\n索引是数据库中为了加速查询而创建的一种特殊的数据结构。通过在表的列上创建索引，可以显著提高数据检索的效率。索引类似于一本书的目录，能够帮助数据库快速定位到目标数据，而不需要遍历整个表。\n\n#### **索引的类型**：\n\n1. **单列索引**：  \n   索引只针对表中的一列进行优化。常见的有B树索引（B-tree）和哈希索引。\n\n2. **复合索引**（多列索引）：  \n   复合索引针对多个列创建，是多个列的组合。例如，可以为 `姓名` 和 `年龄` 创建复合索引，以提高同时查询这两个字段时的效率。\n\n3. **唯一索引**：  \n   唯一索引保证索引列中的数据是唯一的（即没有重复值）。例如，可以为电子邮件列创建唯一索引，确保每个用户的电子邮件地址都是独一无二的。\n\n4. **全文索引**：  \n   全文索引用于对大文本字段进行全文搜索。它适用于需要对大量文本数据进行快速检索的场景，如博客文章、评论等。\n\n5. **聚集索引**（Clustered Index）：  \n   聚集索引定义了表中数据的物理存储顺序，每个表只能有一个聚集索引。主键通常是聚集索引。\n\n6. **非聚集索引**（Non-clustered Index）：  \n   非聚集索引则不改变表中数据的物理存储顺序，一个表可以有多个非聚集索引。非聚集索引会为每个索引创建一个独立的数据结构，指向实际的表数据。\n\n#### **索引的优点**：\n\n- **提高查询速度**：索引通过减少需要扫描的行数，加快了查询操作的执行速度，尤其是在大型表中。\n- **提高排序和分组的效率**：索引能够帮助加速 `ORDER BY` 和 `GROUP BY` 语句的执行。\n\n#### **索引的缺点**：\n\n- **插入和更新性能的影响**：虽然索引提高了查询性能，但在插入、更新或删除操作时，索引需要同步更新，可能会影响这些操作的性能。\n- **占用空间**：索引需要额外的存储空间，尤其是对大型表的多个列创建索引时，会占用较多磁盘空间。\n\n#### **索引的应用场景**：\n\n- **频繁查询的列**：对那些经常被用于查询条件的列创建索引，如 `WHERE` 子句中的列。\n- **排序和分组的列**：如果查询中经常使用 `ORDER BY` 或 `GROUP BY` 子句，可以考虑在排序和分组的列上创建索引。\n- **外键列**：为外键创建索引可以加速关联表的连接查询。\n\n### **总结**\n\n- **事务**：事务确保了数据操作的一致性和完整性，适用于需要保证数据准确性的场景，如金融、订单处理等。事务具有ACID特性，能够确保数据操作的可靠性。\n- **索引**：索引用于加速数据库查询，适合用于频繁查询的场景。虽然索引能够显著提高查询性能，但也可能对插入、更新和删除操作产生影响，因此在设计索引时需要平衡查询性能和写性能。\n\n通过合理设计事务和索引，可以确保数据库系统的高性能和数据的一致性。","tags":["数据库"],"categories":["数据库"]},{"title":"范式","url":"/2024/06/18/范式/","content":"在数据库设计中，**范式**（Normal Form）是一组规范，用于组织数据库中的数据以减少数据冗余和避免数据异常。范式通过定义关系表的结构，确保数据能够以一种高效且一致的方式进行存储和操作。数据库的范式化过程通常被称为**规范化**（Normalization）。\n\n<!--more-->\n数据库中常见的几种范式（从低到高）包括：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF）。以下是对这些范式的简要介绍：\n\n### 1. **第一范式（1NF）**\n\n   - **定义**：关系表的每个字段都必须是不可再分的原子值，即每列中的每个值都应该是单一值，而不是列表、集合或嵌套表。\n   - **目的**：确保数据库中的每个字段都存储单一数据，不存在嵌套或复杂数据结构。\n   - **示例**：假设有一个学生信息表，包含 `课程` 列。如果课程列存储多个课程名称（如 \"数学, 物理\"），则该表不满足第一范式。要满足第一范式，课程列中的每个单元格应只包含一个课程名称。\n\n### 2. **第二范式（2NF）**\n\n   - **定义**：在满足第一范式的基础上，第二范式要求表中的每个非主键列必须完全依赖于主键，即不存在部分依赖关系（仅依赖于主键的一部分）。\n   - **目的**：消除部分依赖，确保非主键列完全依赖于整个主键。\n   - **示例**：如果一个表的主键是复合主键（由多个列组成），并且某个非主键列只依赖于主键的一部分而不是整个主键，那么该表就不符合第二范式。为了符合第二范式，需要将部分依赖的列拆分到其他表中。\n\n### 3. **第三范式（3NF）**\n\n   - **定义**：在满足第二范式的基础上，第三范式要求非主键列必须直接依赖于主键，不能依赖于其他非主键列（即不存在传递依赖）。\n   - **目的**：消除传递依赖，确保非主键列仅依赖于主键，而不依赖于其他非主键列。\n   - **示例**：假设一个表中有列 `城市` 和 `国家`，`国家` 列依赖于 `城市` 列，而 `城市` 列依赖于主键。这种情况下存在传递依赖，表不符合第三范式。为了满足第三范式，应该将 `城市` 和 `国家` 列分离到另一个表中。\n\n### 4. **巴斯-科德范式（BCNF）**\n\n   - **定义**：巴斯-科德范式是第三范式的一个更严格版本。它要求每个非主键列都必须完全依赖于主键，且不能有依赖关系中的任何例外情况。\n   - **目的**：进一步消除潜在的依赖问题，确保更高程度的规范化。\n   - **示例**：如果一个表的主键列对非主键列存在部分依赖，或某个非主键列对主键列存在依赖，这种表可能符合第三范式，但不符合BCNF。\n\n### 5. **第四范式（4NF）**\n\n   - **定义**：在满足BCNF的基础上，第四范式要求消除多值依赖。即，一个表中的每个非主键列必须是独立的，不能有多个值同时依赖于主键。\n   - **目的**：消除多值依赖，确保每个非主键列在主键下都具有唯一性和独立性。\n   - **示例**：如果一个表的主键列与多个非主键列存在多对多关系，例如一个学生可以同时选修多个课程，并且一个课程可以被多个学生选修，那么该表可能不满足第四范式。为了符合第四范式，需要将多值依赖拆分为多个表。\n\n### 6. **第五范式（5NF）**\n\n   - **定义**：在满足第四范式的基础上，第五范式要求消除所有的连接依赖（Join Dependency）。即，任何数据依赖关系都应当被分解，确保无冗余的数据连接。\n   - **目的**：确保数据库完全规范化，消除可能导致冗余的所有连接依赖。\n   - **示例**：如果一个表需要通过多张表的联合才能恢复出完整的数据，可能存在连接依赖问题。为满足第五范式，需要进一步分解表，消除这些依赖关系。\n\n### 规范化与反规范化：\n\n- **规范化**：通过将表分解为满足更高范式的多个子表，减少数据冗余和更新异常，提高数据一致性。\n- **反规范化**：有时为了提高查询性能，可能会牺牲一定的范式规范化，允许一定的数据冗余，以减少表连接操作。这被称为反规范化。\n\n### 何时使用范式：\n\n- **规范化的好处**：减少数据冗余，避免数据更新异常，确保数据一致性。\n- **反规范化的场景**：当查询性能成为首要考虑时，可能会使用反规范化，特别是在读操作远多于写操作的场景中。\n\n总体而言，数据库设计中使用范式是为了确保数据存储的合理性、规范性，并减少数据的重复和不一致性。","tags":["数据库"],"categories":["数据库"]},{"title":"常见数据库","url":"/2024/06/16/常见数据库/","content":"### 1. **Redis**（Remote Dictionary Server）\n\n- **类型**：内存数据库、键值数据库（Key-Value Store）\n- **架构**：Redis 是基于内存的 NoSQL 数据库，主要将数据存储在内存中，并可以选择性地将数据持久化到磁盘。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。\n- **优点**：\n  - **高性能**：由于数据存储在内存中，读写操作非常快，适用于需要低延迟访问的场景。\n  - **多种数据结构**：支持丰富的数据类型，不仅限于简单的键值对，还支持复杂的数据结构。\n  - **支持持久化**：虽然是内存数据库，但可以通过快照（RDB）或日志（AOF）将数据持久化到磁盘。\n  - **支持分布式与集群**：支持分布式模式，能够横向扩展，并通过 Redis Cluster 实现集群管理。\n- **应用场景**：缓存、会话管理、排行榜、计数器、实时数据分析、消息队列。\n<!--more-->\n\n### 2. **MySQL**\n\n- **类型**：关系型数据库管理系统（RDBMS）\n- **架构**：基于行的存储方式，采用 SQL 语言进行查询操作，支持 ACID（原子性、一致性、隔离性、持久性）事务管理。\n- **优点**：\n  - **广泛使用**：作为开源数据库，MySQL 是最常用的关系型数据库之一，广泛用于Web应用。\n  - **强大的 SQL 查询**：支持复杂的 SQL 查询、事务处理以及数据完整性约束。\n  - **数据持久化**：所有数据默认持久化到磁盘。\n  - **社区与支持**：拥有强大的社区支持和丰富的插件、工具生态。\n- **应用场景**：电子商务网站、内容管理系统（CMS）、ERP、CRM 等需要结构化数据存储和复杂查询的应用。\n\n### 3. **PostgreSQL**\n\n- **类型**：对象关系型数据库管理系统（ORDBMS）\n- **架构**：类似 MySQL，基于行的存储方式，支持 ACID 事务管理，并且具有对象关系数据库的特性，允许定义复杂的数据类型。\n- **优点**：\n  - **扩展性强**：支持用户自定义数据类型、函数和操作符，扩展能力非常强。\n  - **复杂查询能力**：支持复杂的 SQL 查询、全文搜索、地理信息数据（GIS）等。\n  - **数据完整性**：支持复杂的约束和触发器，保证数据的一致性和完整性。\n  - **标准支持**：对 SQL 标准的支持优于 MySQL，提供更多高级特性，如CTE、窗口函数等。\n- **应用场景**：金融系统、数据分析平台、GIS（地理信息系统）、需要复杂数据处理的应用。\n\n### 4. **MongoDB**\n\n- **类型**：NoSQL 文档型数据库\n- **架构**：MongoDB 是基于文档存储的 NoSQL 数据库，数据以 BSON 格式（类似 JSON）存储，支持动态架构。\n- **优点**：\n  - **灵活的数据模型**：无需预定义数据架构，数据以文档形式存储，字段可以灵活扩展。\n  - **高可扩展性**：支持水平扩展，能够处理大规模数据集。\n  - **适合半结构化数据**：非常适合存储半结构化或非结构化数据，如日志、社交媒体数据等。\n  - **地理空间查询**：内置地理空间数据处理功能，适合地图和位置服务相关的应用。\n- **应用场景**：内容管理系统、社交媒体、日志管理、物联网数据存储、大数据应用。\n\n### 5. **Elasticsearch**\n\n- **类型**：分布式搜索引擎、文档存储数据库\n- **架构**：Elasticsearch 是一个基于 Lucene 的开源分布式搜索引擎，数据以文档形式存储，支持全文搜索和实时数据处理。\n- **优点**：\n  - **强大的全文搜索能力**：支持复杂的文本搜索和分析，适合需要高效搜索的场景。\n  - **实时分析**：支持实时数据分析和检索，能够处理大规模的日志和事件数据。\n  - **分布式架构**：内置分布式支持，能够轻松扩展处理大量数据。\n- **应用场景**：日志分析（如 ELK 堆栈）、搜索引擎、推荐系统、实时数据流处理。\n\n### 6. **Cassandra**\n\n- **类型**：分布式 NoSQL 列族数据库\n- **架构**：Cassandra 是一个分布式的 NoSQL 数据库，使用列族存储模型，设计上无中心化，支持大规模分布式数据存储和线性扩展。\n- **优点**：\n  - **高可用性和可扩展性**：支持多数据中心、无中心化的分布式架构，具有很高的可用性和可扩展性。\n  - **海量数据存储**：擅长处理非常大的数据集，适用于大规模分布式系统。\n  - **强一致性和高吞吐量**：能够在保证强一致性的前提下处理高并发写操作。\n- **应用场景**：物联网数据、金融数据、高并发的社交媒体平台、实时数据处理。\n\n### 总结：\n\n- **Redis**：高性能、基于内存的键值存储，适合缓存、实时数据处理。\n- **MySQL**：流行的关系型数据库，适合结构化数据和传统业务系统。\n- **PostgreSQL**：扩展性强的对象关系数据库，适合复杂查询和数据分析。\n- **MongoDB**：灵活的文档型数据库，适合半结构化数据和大数据应用。\n- **Elasticsearch**：强大的搜索引擎，适合全文搜索和日志分析。\n- **Cassandra**：高可用性和可扩展性的分布式列族数据库，适合大规模数据存储和处理。","tags":["数据库"],"categories":["数据库"]},{"title":"分布式系统","url":"/2024/05/16/分布式系统/","content":"**分布式系统**是指将任务分散到多台计算机上协同工作，以共同完成一项任务的系统。与集中式系统不同，分布式系统没有一个中心控制节点，而是通过多个节点的协作来实现系统的功能。分布式系统通常用于处理大量数据、提高系统的可用性和性能，并且能够在大规模的网络环境中扩展。\n<!--more-->\n### 1. **分布式系统的基本特征**\n\n- **分布性**：系统的计算和存储资源分布在多个物理位置上，通常这些位置通过网络连接。\n- **并发性**：多个节点可以并发地执行任务，这些任务可能是独立的，也可能需要彼此协作。\n- **故障独立性**：系统能够容忍部分节点的故障，继续提供服务。分布式系统的高可用性通常通过冗余和容错机制来实现。\n- **扩展性**：分布式系统可以通过增加更多的节点来扩展计算能力和存储能力，从而处理更大的工作负载。\n\n### 2. **分布式系统的组成**\n\n分布式系统通常由多个独立的计算节点组成，这些节点通过网络相互通信，共同完成任务。根据不同的应用场景，分布式系统的组成和架构可以有所不同。常见的分布式系统包括以下几个部分：\n\n- **计算节点**：承担计算任务的独立服务器或虚拟机，这些节点通过任务分配和协同完成系统的计算工作。\n- **存储节点**：负责存储数据的节点，数据通常被分布式存储在多个存储节点中，以提高数据的可靠性和可用性。\n- **通信机制**：分布式系统中的节点通过网络相互通信。常见的通信机制包括消息队列、远程过程调用（RPC）等。\n- **协调服务**：分布式系统中的协调服务（如ZooKeeper）用于管理节点之间的状态同步、分布式锁、领导选举等功能。\n\n### 3. **分布式系统的类型**\n\n根据具体的功能和应用场景，分布式系统可以分为以下几种类型：\n\n- **分布式计算系统**：将计算任务分配到多个节点上并行处理，常用于高性能计算、大规模数据处理等场景。例如，Hadoop和Spark是常见的分布式计算框架。\n\n- **分布式存储系统**：将数据分散存储在多个节点上，确保数据的高可用性和可靠性，适用于海量数据存储和快速访问的场景。例如，Amazon S3、Google File System (GFS)、Cassandra等。\n\n- **分布式数据库**：将数据库系统的数据和查询分布在多个节点上，提高数据处理能力和容错性。例如，MongoDB、Cassandra、Google Spanner 等。\n\n- **分布式消息队列系统**：用于在分布式环境中传递消息，支持异步通信和任务调度。例如，Apache Kafka、RabbitMQ、ActiveMQ等。\n\n### 4. **分布式系统的挑战**\n\n尽管分布式系统具有高扩展性和容错性等优点，但它们也面临着一些挑战和复杂性：\n\n- **一致性问题**：分布式系统中的多个节点之间的数据一致性是一个关键问题，尤其是在网络分区或节点故障时。为了解决一致性问题，分布式系统通常采用一致性协议（如Paxos、Raft）来保证数据的一致性。\n\n- **网络延迟**：分布式系统中的节点通过网络进行通信，网络延迟会影响系统的性能和响应时间。为了减少网络延迟带来的影响，系统设计时需要考虑到数据的本地化和负载均衡等因素。\n\n- **容错性**：分布式系统中的某些节点可能会出现故障，因此系统需要具备容错能力，即在部分节点出现故障时仍能正常工作。常见的容错技术包括数据冗余、主备切换等。\n\n- **复杂性管理**：分布式系统涉及多个节点、通信机制、数据一致性管理等，系统的复杂性较高，开发和运维成本也更高。\n\n### 5. **CAP定理**\n\nCAP定理是分布式系统中的一个重要理论，它指出在一个分布式系统中，不可能同时满足以下三个属性：\n\n1. **一致性（Consistency）**：所有节点在同一时刻具有相同的数据副本，即每次读取都能获取到最新的数据。\n2. **可用性（Availability）**：每次请求都会收到一个成功的响应，但不保证返回的数据是最新的。\n3. **分区容错性（Partition Tolerance）**：系统能够容忍网络分区的情况，即即使网络中出现节点之间无法通信的情况，系统仍然能够正常运行。\n\n根据CAP定理，分布式系统设计时需要在一致性、可用性和分区容错性之间做出权衡。大多数分布式系统通常选择牺牲一致性来保证可用性和分区容错性。\n\n### 6. **常见的分布式系统架构**\n\n- **主从架构（Master-Slave Architecture）**：在主从架构中，主节点（Master）负责协调任务，并将任务分发给从节点（Slave）进行处理。从节点将结果返回给主节点，主节点负责整合并返回最终结果。常见的应用场景包括分布式文件系统（如HDFS）和数据库复制。\n\n- **对等架构（Peer-to-Peer Architecture）**：在对等架构中，所有节点都是对等的，没有中心控制节点。每个节点既可以作为客户端，也可以作为服务器，处理任务并共享资源。常见的应用场景包括P2P文件共享、区块链等。\n\n- **分片架构（Sharding Architecture）**：在分片架构中，将数据或任务分片，分配到不同的节点上。每个节点负责处理自己的一部分数据或任务，从而提高系统的并行处理能力。常见的应用场景包括分布式数据库、分布式存储系统等。\n\n### 7. **分布式系统的应用场景**\n\n- **大数据处理**：分布式计算系统可以处理海量数据，如Hadoop、Spark等，用于批处理、流处理和数据分析。\n\n- **云计算**：云计算平台（如AWS、Google Cloud）本质上是一个大型分布式系统，通过虚拟化技术将计算和存储资源分布在全球范围内的多个数据中心。\n\n- **容器编排**：如Kubernetes，它用于管理分布式容器化应用程序，自动化部署、扩展和管理容器化的工作负载和服务。\n\n- **微服务架构**：微服务是一种分布式系统架构，将应用程序分解为多个独立的服务，每个服务都可以独立开发、部署和扩展。\n\n### 8. **分布式系统的未来**\n\n随着数据量和计算需求的不断增加，分布式系统在各个领域的应用将会更加广泛。未来的发展趋势可能包括：\n\n- **无服务器架构（Serverless）**：开发者无需管理服务器，计算资源由云提供商按需分配。\n- **边缘计算**：将计算和数据存储分布到更靠近用户的边缘节点，减少延迟，适用于物联网和实时应用场景。\n\n### 总结\n\n分布式系统通过将计算和存储任务分布到多个节点来实现更高的性能、可扩展性和可靠性。然而，分布式系统也面临着一致性、网络延迟和容错性等挑战。理解分布式系统的基本原理、架构和常见的设计模式，对于构建现代大规模应用至关重要。","tags":["软件"],"categories":["软件"]},{"title":"观察者模式","url":"/2024/03/19/观察者模式/","tags":["软件"],"categories":["软件"]},{"title":"SEO","url":"/2024/03/16/SEO/","content":"**SEO（Search Engine Optimization，搜索引擎优化）**是一种通过优化网站内容和技术结构，以提升网站在搜索引擎中自然搜索结果排名的技术和策略。SEO的目标是提高网站在搜索引擎中的可见性，从而吸引更多的有机（非付费）流量。\n<!--more-->\n### SEO的核心要素：\n\n1. **关键词优化**：\n   - 选择合适的关键词，并在页面内容、标题、描述、URL等位置合理使用这些关键词，帮助搜索引擎理解页面的主题。\n   - 关键词密度要自然，避免过度堆砌，以免被搜索引擎识别为作弊行为。\n\n2. **内容质量**：\n   - 优质的内容是SEO的基础。高质量、原创、与用户搜索意图相关的内容会得到搜索引擎的青睐。\n   - 定期更新内容，确保信息的时效性和相关性。\n\n3. **网站结构优化**：\n   - 合理的网站结构能够帮助搜索引擎更好地抓取和索引内容。清晰的导航、逻辑层次分明的页面结构、面包屑导航等都是良好的网站结构实践。\n   - 创建XML网站地图，帮助搜索引擎更快地了解网站的页面布局。\n\n4. **移动端优化**：\n   - 随着移动设备使用量的增加，移动端的SEO变得越来越重要。确保网站在移动设备上的加载速度、可用性、用户体验都达到较高标准。\n   - 响应式设计可以帮助网站在不同设备上自适应布局，提升用户体验。\n\n5. **页面加载速度**：\n   - 页面加载速度是SEO排名中的一个重要因素。优化图片大小、启用浏览器缓存、压缩代码、使用内容分发网络（CDN）等技术都可以提升网站的加载速度。\n\n6. **外链建设**：\n   - 高质量的外部链接（即其他网站指向你网站的链接）可以显著提升网站的权威性和在搜索引擎中的排名。\n   - 外链应来自相关性高、信誉良好的网站。避免低质量的外链，因为这些可能会对SEO产生负面影响。\n\n7. **技术优化**：\n   - 确保网站使用安全的HTTPS协议，避免页面出现错误或死链。\n   - 使用结构化数据（如Schema.org标记），帮助搜索引擎更好地理解页面的内容。\n\n8. **用户体验**：\n   - 搜索引擎越来越重视用户体验（User Experience, UX）。页面的跳出率、停留时间、用户交互行为都会影响SEO排名。\n   - 提升用户体验可以增加用户在网站上的停留时间，降低跳出率，从而改善SEO表现。\n\n### SEO的分类：\n\n1. **站内SEO（On-page SEO）**：\n   - 站内SEO主要关注网站内部的优化，例如关键词的使用、内容质量、页面结构、内部链接、图片优化等。\n\n2. **站外SEO（Off-page SEO）**：\n   - 站外SEO则涉及到外部因素的优化，例如外链建设、社交媒体推广、品牌曝光等。站外SEO有助于提升网站的权威性和可信度。\n\n### SEO的挑战：\n\n- **算法更新**：搜索引擎（特别是Google）会定期更新其算法，影响排名的规则可能发生变化，因此SEO策略需要持续调整。\n- **竞争激烈**：热门关键词的竞争通常非常激烈，需要持续的努力和优化才能在搜索结果中占据优势位置。\n- **时间成本**：SEO的效果通常是长期积累的，需要时间来显现，且需要持续优化和维护。\n\n### 常见的SEO工具：\n\n- **Google Analytics** 和 **Google Search Console**：用于监控网站流量、用户行为和搜索表现。\n- **Ahrefs**、**SEMrush**：用于关键词研究、竞争分析和外链建设。\n- **Yoast SEO**：WordPress网站上常用的SEO插件，帮助优化页面内容和结构。\n\nSEO不仅仅是技术优化，还包括内容策略、用户体验提升和品牌推广的综合策略。通过正确的SEO实践，网站可以在搜索引擎中获得更高的曝光度，吸引更多的有机流量，并实现更好的业务增长。\n\n","tags":["SEO"],"categories":["SEO"]},{"title":"微服务、宏服务","url":"/2024/02/16/微服务、宏服务/","content":"在JavaScript中，虽然微服务和宏服务是常见的术语，但它们更多是与分布式系统和服务架构相关的概念，而不是与JavaScript语言本身直接相关。JavaScript中更常用的术语是**微任务**和**宏任务**，它们与事件循环机制和异步编程密切相关。\n<!--more-->\n\n此外，**回调地狱**问题的解决方案主要涉及到现代JavaScript中的异步编程技术，如`Promise`、`async/await`等。以下是详细的解释：\n\n### 1. **微任务（Microtasks）与宏任务（Macrotasks）**\n\n微任务和宏任务是JavaScript事件循环（Event Loop）中两种不同的任务类型，它们决定了异步代码的执行顺序。\n\n- **宏任务（Macrotask）**：\n  宏任务是JavaScript中每次事件循环处理的基本任务单元。常见的宏任务包括：\n\n  - `setTimeout`\n  - `setInterval`\n  - `I/O操作`\n  - DOM事件处理\n\n  宏任务会被放入任务队列中，等待事件循环调度执行。JavaScript引擎会在每次事件循环时处理一个宏任务，并在执行完毕后再检查微任务队列。\n\n- **微任务（Microtask）**：\n  微任务是比宏任务优先级更高的一类任务，它们会在当前事件循环结束时立即执行（在下一个宏任务开始之前）。常见的微任务包括：\n\n  - `Promise.then()` 或 `Promise.catch()` 回调\n  - `process.nextTick()`（Node.js中特有）\n  - `MutationObserver`（用于监听DOM变化）\n\n  微任务是在当前宏任务执行完毕后立刻执行的，因此可以在更高优先级的情况下处理任务。微任务队列会在每次宏任务执行后清空。\n\n**执行顺序**：当一个宏任务完成时，JavaScript引擎会首先清空微任务队列中的所有任务，然后再去执行下一个宏任务。\n\n### 2. **回调地狱（Callback Hell）**\n\n回调地狱是指在处理异步操作时，多个回调函数嵌套使用，导致代码变得难以维护和理解的情况。例如，当多个异步操作需要按顺序执行时，可能会出现深层嵌套的回调，形成“金字塔”结构，如下：\n\n```javascript\ndoSomething(function(result) {\n  doSomethingElse(result, function(newResult) {\n    doThirdThing(newResult, function(finalResult) {\n      console.log(finalResult);\n    });\n  });\n});\n```\n\n这种嵌套结构让代码可读性变差，错误处理也变得困难。\n\n### 3. **解决回调地狱的方案**\n\nJavaScript中有几种常用的方式来解决回调地狱的问题，使异步代码更简洁和可维护：\n\n#### **1. Promise**\n\n`Promise` 是一个用于处理异步操作的对象，它可以将回调链平坦化，从而避免回调地狱。`Promise`允许我们将异步操作串联起来，并使用`.then()`链式调用，解决深层回调嵌套的问题。\n\n```javascript\ndoSomething()\n  .then(result => doSomethingElse(result))\n  .then(newResult => doThirdThing(newResult))\n  .then(finalResult => console.log(finalResult))\n  .catch(error => console.error(error));\n```\n\n`Promise` 提供了 `.then()`、`.catch()` 和 `.finally()` 方法，来分别处理成功、失败和最终的逻辑。通过这种方式，可以将多个异步操作串联成链式调用，避免深层嵌套。\n\n#### **2. async/await**\n\n`async/await` 是基于 `Promise` 的语法糖，允许我们用同步代码的方式编写异步代码。它能够让代码更简洁和可读，同时保留了异步操作的优点。\n\n```javascript\nasync function run() {\n  try {\n    const result = await doSomething();\n    const newResult = await doSomethingElse(result);\n    const finalResult = await doThirdThing(newResult);\n    console.log(finalResult);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nrun();\n```\n\n在 `async/await` 中，`await` 可以暂停函数的执行，等待 `Promise` 解析，然后继续执行。这种写法使得异步代码看起来像同步代码，极大地提升了代码的可读性，并且支持常规的 `try/catch` 异常处理机制。\n\n#### **3. 生成器（Generator）**\n\n虽然生成器在解决回调地狱的问题上不如 `Promise` 和 `async/await` 常用，但它们也可以通过 `yield` 和 `co` 库来实现类似的效果。\n\n```javascript\nfunction* main() {\n  try {\n    const result = yield doSomething();\n    const newResult = yield doSomethingElse(result);\n    const finalResult = yield doThirdThing(newResult);\n    console.log(finalResult);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// 使用 co 库来运行生成器函数\nco(main);\n```\n\n生成器函数通过 `yield` 暂停执行，可以一步一步地处理异步操作。不过，随着 `Promise` 和 `async/await` 的流行，生成器函数在这方面的使用变得较少。\n\n### 总结\n\n- **微任务**和**宏任务**是 JavaScript 事件循环中的概念，决定了异步代码的执行顺序。微任务（如 `Promise` 回调）优先于宏任务（如 `setTimeout`）。\n- **回调地狱**问题可以通过使用 `Promise`、`async/await` 等技术解决，这些技术使得异步代码更加简洁、可读，并且更容易进行错误处理。\n\n掌握这些概念和技术，能够帮助开发者更好地处理 JavaScript 中的异步编程，提高代码质量和可维护性。","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"SSR","url":"/2023/05/16/SSR/","content":"\n**前端SSR（Server-Side Rendering，服务器端渲染）**是一种在服务器上渲染网页内容的技术，与客户端渲染（Client-Side Rendering，CSR）相对。具体来说，SSR是在服务器端将前端框架（如Vue、React）的代码渲染成HTML，然后将完整的HTML页面直接发送给客户端浏览器。这样，浏览器在接收到页面时，已经是渲染好的内容，无需额外等待客户端脚本执行来生成页面内容。\n<!--more-->\n### SSR的主要特点：\n\n1. **快速首屏加载**：由于页面的HTML内容在服务器端已经渲染完成，客户端无需等待JavaScript加载和执行，用户可以立即看到页面内容，减少了白屏时间，提升了用户体验。\n2. **更好的SEO支持**：SSR生成的HTML是直接渲染好的静态内容，搜索引擎爬虫能够更好地抓取和索引，从而提升SEO效果，而CSR的内容有时难以被搜索引擎完全抓取。\n3. **对低性能设备更友好**：SSR减少了客户端对计算资源的需求，因为页面的渲染工作已经在服务器端完成，这对低性能设备的用户更加友好。\n\n### SSR的挑战：\n\n1. **服务器压力增加**：由于渲染工作由服务器承担，会增加服务器的负载，特别是在访问量大时，可能会对服务器性能提出更高要求。\n2. **开发复杂性增加**：SSR相比CSR开发起来更为复杂，开发者需要处理更多的服务器端逻辑，以及前后端状态的同步问题。\n3. **页面交互的延迟**：虽然首屏加载速度快，但后续的交互体验可能会稍微慢于CSR，因为需要考虑到服务器渲染和客户端渲染的结合。\n\n### 常见的SSR框架：\n\n- **Next.js**：React的流行SSR框架，提供了强大的SSR和静态生成功能。\n- **Nuxt.js**：Vue.js的SSR框架，简化了SSR在Vue项目中的实现。\n\nSSR技术在优化首屏加载速度和提升SEO效果方面有显著的优势，特别适用于需要快速展示内容并依赖搜索引擎优化的应用场景。\n\n","tags":["SSR"],"categories":["SSR"]},{"title":"node接口","url":"/2022/08/21/node接口/","content":"\n\n> Node.js对一些特殊用例进行优化，提供替代的[API](https://baike.baidu.com/item/API/10154?fromModule=lemma_inlink)，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的[网络应用](https://baike.baidu.com/item/网络应用/2196523?fromModule=lemma_inlink)。\n\n<!--more-->\n## 创建\n\n1. 通过 npm init 创建 package.json文件\n2. 通过npm install express 安装express模块\n3. 创建app.js写入以下代码\n4. node app.js 启动\n\n```js\n//导入\nconst express = require('express')\n//创建\nconst app = express()\n\napp.get('/user',(req,res) => {\n    res.send({ name:'zs', age: 20, gender:'男' })\n})\napp.post('/user',(req,res) => {\n    res.send('请求成功');\n})\n\n\n//启动\napp.listen(80,() => {\n    console.log('express server running at http://127.0.0.1');\n})\n\n```\n\n## Express中间件\n\n中间件函数的形参中，必须包含next参数。而路由处理函数中只包含req和res\n\n```js\nconst express = require('express')\n\nconst app = express()\n\nconst mw = function(req,res,next){\n\n    console.log('中间件被调用');\n    next()\n}\n\napp.listen(80,() => {\n    console.log('http://127.0.0.1');\n})\n\n\n\napp.use((req,res,next){\n\tconsole.log('中间件')\n\tnext()\n})\n//中间件的作用可以在上游中间件统一为req或res对象添加自定义属性或方法，供下游的中间件或路由使用\n\n\nconst express = require(\"express\");\n\nconst app = express()\n\napp.use((req,res,next) => {\n    const timeNow = Date.now()\n    req.Nowtime = timeNow\n    next()\n})\n\napp.get('/',function(req,res){\n    res.send('Home page' + req.Nowtime)\n})\n\napp.get('/user',(req,res) => {\n    res.send('User page' + req.Nowtime)\n})\n\napp.listen(80,()=>{\n    console.log('http://127.0.0.1');\n})\n\n\n\n```\n\n### 解析请求数据\n\n```js\n//json\nconst express = require(\"express\");\n\nconst app = express()\n\napp.use(express.json())\n\n//通过express.urlencoded()解析表单 url-encoded格式的数据\napp.use(express.urlencoded({extenden:false}))\n\napp.post('/user',(req,res)=>{\n    //req.body来接收客户端发送过来的请求体数据\n    console.log(req.body);\n    res.send('ok')\n})\n\n```\n\n### CORS跨域资源共享\n\nnpm install cors\n\n//在路由之前配置cors解决跨域\n\n```js\nconst cors = require('cors')\napp.use(cors())\n```\n\n\n1、作用\n\ncors由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否组织前端JS代码跨域获取资源\n\n浏览器的同源安全策略默认会阻止网页\"跨域\"获取资源。\n\n主要在服务器端进行配置，客户端无需做任何额外配置\n\n2、cors响应头部\n\n响应头部中可携带Access-Control-Allow-Origin字段\n\nAccess-Control-Allow-Origin: <origin> | *\n//其中origin参数的值指定了允许访问该资源的外域URL,通配符*表示任何域\n\n例如\n\nres.SetHeader('Access-Control-Allow-Origin','https://lnkjzm.cn')\n\n默认情况CORS只支持客户端发起GET、POST、HEAD请求，若使用其他方式：\n\nres.SetHeader('Access-Control-Allow-Methods','POST,GET,DELETE,HEAD')\n\n3、简单请求和预检请求\n\n简单请求：客户端与服务器之间只发生一次请求\n\n预检请求：客户端与服务器之间发生两次请求，OPTION预检请求成功之后才会发生真正请求\n\n","tags":["node"],"categories":["node"]},{"title":"uni-app 生命周期","url":"/2022/08/07/uni-app-生命周期/","content":"生命周期概念：一个对象从创建、运行、销毁的整个过程被称为生命周期\n\n生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数\n<!--more-->\n\n## 应用的生命周期\n\n| 函数名   | 说明                                        |\n| -------- | ------------------------------------------- |\n| onLaunch | 当uni-app初始化完成是触发（全局只触发一次） |\n| onShow   | 当uni-app启动，或从后台进入前台显示         |\n| onHide   | 当uni-app从前台进入后台                     |\n| onError  | 当uni-app报错时触发                         |\n\n## 页面的生命周期\n\n| 函数名   | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| onLoad   | 监听页面加载，其参数为上个页面传递的数据，参数类型为Object(用于页面传承) |\n| onShow   | 监听页面显示，页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |\n| onReady  | 监听页面初次渲染完成                                         |\n| onHide   | 监听页面隐藏                                                 |\n| onUnload | 监听页面卸载                                                 |\n\n## 组件的生命周期\n\n| 函数名        | 说明                                                         | 平台         |\n| ------------- | ------------------------------------------------------------ | ------------ |\n| beforeCreate  | 在实例初始化之后被调用                                       |              |\n| created       | 在实例创建完成后被立刻调用                                   |              |\n| beforeMount   | 在挂载开始之前被调用                                         |              |\n| mounted       | 挂载到实例上去之后调用                                       |              |\n| beforeUpdate  | 数据更新时调用，发生在虚拟DOM打补丁之前                      | 仅H5平台支持 |\n| updated       | 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子 | 仅H5平台支持 |\n| beforeDestroy | 实例销毁之前使用                                             |              |\n| destroyed     | Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 |              |\n\n\n\n\n\n\n\n","tags":["uni-app"],"categories":["uni-app"]},{"title":"Ant Design","url":"/2022/07/29/Ant-Design/","content":"> `antd` 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品\n>\n> [Ant Design]([Ant Design - 一套企业级 UI 设计语言和 React 组件库 (antgroup.com)](https://ant-design.antgroup.com/index-cn))\n\n## 按需加载\n\n```\nnpm add @craco/craco\n```\n<!--more-->\n修改package.json中关于scripts中的配置\n\n```\n\"scripts\": {\n    \"start\": \"craco start\",\n    \"build\": \"craco build\",\n    \"test\": \"craco test\",\n    \"eject\": \"react-scripts eject\"\n  },\n```\n\n初始化babel\n\n```\nnpm install babel-plugin-import\n```\n\n在根目录新建craco.config.js文件\n\n```\nmodule.exports = {\n    babel: {//支持装饰器\n        plugins: [\n            [\n                \"import\",\n                {\n                    \"libraryName\": \"antd\",\n                    \"libraryDirectory\": \"es\",\n                    \"style\": 'css' //设置为true即是less 这里用的是css\n                }\n            ]\n        ]\n    },\n};\n```\n\n使用\n\n```\nimport { Button } from 'antd';\n<Button type=\"primary\">Primary Button</Button>\n```\n\n","tags":["React"],"categories":["React"]},{"title":"React hooks","url":"/2022/07/21/React-hooks/","content":"\n> *Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。[官方文档]([Hooks FAQ – React (docschina.org)](https://react.docschina.org/docs/hooks-faq.html))\n\nReact有类组件和函数组件。两种组件最明显的不同在于语法上，函数组件是一个纯函数，它接收一个props对象返回一个react元素。而类组件需要去继承React.Component并且创建render函数返回react元素，需要更多的代码，但实现的效果相同。需要注意的是，在函数组件中不能使用生命周期钩子。\n\n<!--more-->\nReact Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。\n\n这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。\n\n## useState\n\n在函数组件中，可以使用`useState`来定义函数组件的状态。使用`useState`来创建状态\n\n- 1.引入\n- 2.接收一个参数作为初始值\n- 3.返回一个数组，第一个值为状态，第二个值为改变状态的函数\n\n```jsx\nimport React,{ useState } from 'react'\n\nconst [name, setName] = useState('小明')\n //     类名，修改函数名            初始值\n```\n\n## useEffect\n\n`useEffect`又称副作用`hooks`。作用：给没有生命周期的组件，添加结束渲染的信号。执行时机：在渲染结束之后执行\n\n- 什么是副作用？\n  - 副作用 ( side effect ): 数据获取，数据订阅，以及手动更改 React 组件中的 DOM 都属于副作用\n  - 因为我们渲染出的页面都是静态的，任何在其之后的操作都会对他产生影响，所以称之为副作用\n- 使用：\n  - 1.第一个参数，接收一个函数作为参数\n  - 2.第二个参数，接收【依赖列表】，只有依赖更新时，才会执行函数\n  - 3.返回一个函数，先执行返回函数，再执行参数函数\n\n如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用`useEffect`的回调函数。\n\n```jsx\nimport { useEffect } from 'react'\n\nuseEffect( () => {\n     console.log('Hello World!!')\n},[])\n```\n\n## useContext\n\n`useContext`是让子组件之间共享父组件传入的状态的\n\n- 需要引入`useContetx`，`createContext`两个内容\n- 通过`createContext`创建一个context句柄\n- `Context.Provider`来确定数据共享范围\n- 通过`value`来分发内容\n- 在子组件中，通过`useContext(Context句柄)`来获取数据\n- **注意**上层数据发生改变，肯定会触发重新渲染（点击`button`按钮触发父组件更新传入的`num`值能看到子组件重新渲染）\n\n```jsx\nconst Context = createContext(null)  \nfunction StateFunction () {  \n    const [num, setNum] = useState(1)  \n    return (  \n        <div>  \n            <button onClick={ ()=> setNum(num => num+1) }>增加num的值+1</button>  \n            <br></br>  \n            这是一个函数式组件——num:{  num }  \n            <Context.Provider value={num}>  \n                <Item3></Item3>  \n                <Item4></Item4>  \n            </Context.Provider>  \n        </div>  \n    )  \n}  \nfunction Item3 () {  \n    const num = useContext(Context)  \n    return (  \n        <div>  \n            子组件3: { num }  \n        </div>  \n    )  \n}  \nfunction Item4 () {  \n    const num = useContext(Context)  \n    return (  \n        <div>  \n            子组件4: { num+2 }  \n        </div>  \n    )  \n}  \n```\n\n\n\n","tags":["React"],"categories":["React"]},{"title":"Vue组件","url":"/2022/07/17/Vue组件/","content":"组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。vue组件是把页面（html代码，CSS代码）进行模块化。\n\n当一个界面的功能很复杂时，可以变成多个组件来实现页面。\n\n作用是复用编码，简化项目编码，提高运行效率。\n\nVueCompoent简称vc,vc是组件的实例对象，vm是Vue的实例对象，vm管理vc。有多个vc，但vm是唯一的，只有一个el。\n\n## 使用组件\n\n在vue脚手架中使用组件的步骤有三步，定义组件，注册组件，使用组件\n\n<!--more-->\n```\n//About.vue\n<template>\n  <div class=\"about\">\n    <h1>这是组件</h1>\n  </div>\n</template>\n\n\n<template>\n  <div id=\"app\">\n    //使用组件\n    \n    <HelloWorld />\n  </div>\n</template>\n\n<script>\n//引入\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nexport default {\n  el:\"#app\",\n  //注册组件\n  components: {\n    HelloWorld\n  }\n}\n</script>\n\n```\n\n## 组件间数据通信\n\n### 1.子组件访问父组件数据\n\n在调用子组件时，绑定想要获取的父组件中的数据在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据。即父组件通过props向下传递数据给子组件。\n注：组件中的数据存在方式共有三种：data、props、computed\n\nprops传递数据两种形式\n\n数组方式： props:['msg', 'username', 'age', 'userObj']\n对象方式：该方式提供了对数据的校验、类型监测、默认值设置操作。\n\n在vue脚手架中，父传子\n\n```\n//父组件\n<father :bookList=\"bookList\"/>\n//子组件\nprops:{\n\tbookList:{\n\t\ttype:String,//类型\n\t\trequired: true //必要性\n\t}\n}\n\n```\n\n### 2.父组件访问子组件的数据（子传父）\n\n    第一步：在子组件中使用 vm.$emit(事件名,数据) 触发一个自定义事件，事件名自定义。\n    \n    第二步：父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据。 \n    \n    总结：子组件通过events（事件）给父组件发送消息，实际上就是子组件把自己的数据发送到父组件\n    \n     <!DOCTYPE html>\n    <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>父组件访问子组件的数据（子传父）</title>\n            <script src=\"../js/vue.js\"></script>\n        </head>\n        <body>\n            <div id=\"app\">\n                <h2>{{info}}</h2>\n                <!--使用局部子组件-->\n                <!--@itemClick绑定自定义的子组件itemClick事件到父组件到回调方法上-->\n                <component-a @item-click=\"parentClick\"></component-a>\n            </div>\n        </body>\n        <template id=\"myTemplate\">\n            <div>\n                <!--根据分类展示多个按钮, 当点击按钮会调用方法btnClick并把每一类的对象传进去-->\n                <input type=\"button\" v-for=\"item in categories\" v-bind:value=\"item.name\" @click=\"btnClick(item)\">\n            </div>\n        </template>\n        <script>\n            //定义组件\n            let componentA = {\n                template: `#myTemplate`,\n                data() {\n                    return {\n                        //分类\n                        categories: [\n                            {id: 1, name: \"电脑\"},\n                            {id: 2, name: \"衣帽\"},\n                            {id: 3, name: \"零食\"},\n                            {id: 4, name: \"生鲜\"}\n                        ],\n                    }\n                },\n                methods: {\n                    btnClick(item) {\n                        //触发自定义的事件, 同时把item事件传进去\n                        //$emit(\"自定义的事件名称\", 数据) 触发自定义的事件\n                        //自定义事件的名称, 全部小写字母或短横线, 不能使用驼峰, 因为html不区分大小写\n                        this.$emit(\"item-click\", item);\n                    }\n                }\n            };\n            let vm = new Vue({\n                el: \"#app\",\n                data() {\n                    return {\n                        info: \"哈哈\",\n                    }\n                },\n                //注册组件\n                components: {\n                    \"component-a\": componentA,\n                },\n                methods: {\n                    //父组件的回调函数, 接收参数(参数是子组件触发自定义事件传进来的)\n                    parentClick(item) {\n                        this.info = `子组件点击了按钮, 父组件收到子组件数据id为:${item.id},name为:${item.name}`;\n                    }\n                }\n            })\n        </script>\n    </html>\n\n### 3.非父子通信\n\n创建一个Vue实例作为中央事件总线，通过它来监听($on)和触发($emit)事件。适用于组件间全部通信方式。\n\n```js\n//实例Vue实例作为中央事件总线\nvar Event=new Vue();\n//发送事件\nEvent.$emit(事件名,数据);\n//监听事件\nEvent.$on(事件名,data => {});\n```\n\n\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"axios常用请求","url":"/2022/07/12/axios常用请求/","content":"## axios常见4种请求方法\n\n**1、get请求**\n\n用于获取数据。\n\n```js\n \t//写法一\n\tcurrentPage是传进来的参数\n            axios.get(''/Bookf/'+currentPage+'/5'', {\n                params: {\n                    id: 12,//请求参数\n                },\n            }).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'get',//请求方法\n                params: {\n                    id: 12,//请求参数\n                },\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n<!--more-->\n**2、post请求**\n\n用于提交数据（新建）、包括表单提交及文件上传。\n\n```js\n\t\t //写法一\n            let data={\n                id:12\n            }\n            axios.post('接口地址', data}).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'post',//请求方法\n                data: data,\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n\n**3、put请求**\n\n用于更新数据（修改），将所有数据都推送到后端。\n\n```js\n\t\t\t//写法一\n            let data = {\n                id:12\n            }\n            axios.put('接口地址', data}).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'put',//请求方法\n                data: data,\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n\n**4、delete请求**\n\n用于删除数据。\n\n```js\n  \t\t\t//写法一\n            let data = {\n                id:12\n            }\n            //url传递参数\n            axios.delete('接口地址', {\n                parmas:{\n                    id:12\n                }\n            }).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //post方式传递参数\n            axios.delete('接口地址', {\n                data:{\n                    id:12\n                }\n            }).then(\n                (res) => {\n                    //执行成功后代码处理\n                }\n            )\n            //写法二\n            axios({\n                method: 'patch',//请求方法\n                parmas:{\n                    id:12\n                },\n                url: '后台接口地址',\n            }).then(res => {\n                //执行成功后代码处理\n            })\n```\n\n\n\n### 全局使用axios\n\n注意vue3中没有vue.prototype,使用需要使用别的方法写默认端口\n\n```\nVue3\n\nimport axios from 'axios'\nconst app = createApp(App)\napp.config.globalProperties.$axx=axios\naxios.defaults.baseURL='/api'\n\napp.use(store).use(router).mount('#app')\n------------------------------------\nVue2\nimport axios from 'axios'\nVue.prototype.$axios = axios\naxios.defaults.baseURL='/api'\n```\n\n# ","tags":["axios"],"categories":["axios"]},{"title":"Postman","url":"/2022/07/12/Postman/","content":"## 什么是Postman\n\nPostman是接口测试工具，可用来测试接口是否可用，能不能正常使用，方便前端对接接口\n\n> Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。软件功能非常强大，界面简洁明晰、操作方便快捷，设计得很人性化。Postman中文版能够发送任何类型的HTTP 请求 (GET, HEAD, POST, PUT…)，附带任何数量的参数+ headers。\n>\n> 从可视化界面直接输入要访问的url+参数，就可以获取从后台返回前端的数据，可以以json,xml等多种格式直观的展示出来，尤其对前后端分离的项目有非常好的调试作用。\n\n<!--more-->\n\n## 使用\n\n常用于CRUD，也就是增删查改，选择要发送的请求，输入要访问的路径参数即可。需要注意的，像POST请求是用json传输的，所以不能使用一般的传参，需要在Body里选择raw里的JSON，再编写自己需要上传的数据，如下图所示\n\n从可视化界面直接输入要访问的url+参数，就可以获取从后台返回前端的数据，可以以json,xml等多种格式直观的展示出来，尤其对前后端分离的项目有非常好的调试作用\n![image](Postman/image-20220720013718809.png)\n","tags":["测试工具"],"categories":["测试工具"]},{"title":"节流和防抖","url":"/2022/07/10/节流和防抖/","content":"防抖是用户频繁操作，但只执行一次。节流是变少量操作\n\n为应对web页面中频繁触发事件，出现节流和防抖两种优化方案。\n\n**防抖**：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\n **节流**：高频事件触发，但在n秒内只会执行一次，节流会稀释函数的执行频率\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。\n\n<!--more-->\n\n```js\n/*函数节流*/\n\nfunction throttle(fn, interval) {\n\n  var enterTime = 0;//触发的时间\n\n  var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\n\n  return function() {\n\n    var context = this;\n\n    var backTime = new Date();//第一次函数return即触发的时间\n\n    if (backTime - enterTime > gapTime) {\n\n      fn.call(context,arguments);\n\n      enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\n\n    }\n\n  };\n\n}\n\n/*函数防抖*/\n\nfunction debounce(fn, interval) {\n\n  var timer;\n\n  var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\n\n  return function() {\n\n    clearTimeout(timer);\n\n    var context = this;\n\n    var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\n\n    timer = setTimeout(function() {\n\n      fn.call(context,args);\n\n    }, gapTime);\n\n  };\n\n}\n\n\n```\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"路由守卫","url":"/2022/06/27/路由守卫/","content":"\nVue路由守卫是对路由进行权限控制，比如想要用户登录了才能访问页面。分三类，全局守卫、独享守卫、组件内守卫。编写的地方不一样。\n\n1.全局 \n\n​\tbeforeEach、beforeResolve、afterEach\n\n2.路由独享\n\n​\tbeforeEnter\n<!--more-->\n\n3.组件内\n\n​\tbeforeRouteEnter、beforeRouteUpdate、beforeRouteLeave\n\n### 实际应用\n\n```js\nrouter.beforeEach((to, from, next) => {\n  NProgress.start(); // NProgress实现显示加载进度条效果\n  console.log(\"routemgr to\", to.path);\n  if (\"这里判断是不是开发环境\") {\n    //开发环境下，直接路由\n    next();\n  } else {\n    if (to.path == \"/login\") {\n      //登录页面\n      session.set(\"isOpen\", \"ok\");\n      next();\n    } else if (\"这里判断如不是生产环境下录页面需要判断权限\") {\n      //非生产环境下\n      next();\n    } else {\n      //非登录页面需要判断权限\n      console.log(\"routemgr user\", lu.userinfo);\n      if (gadget.isEmptyObject(lu.userinfo)) {\n        //首次打开页面的时候，不需要弹出错误页面提示，直接跳转至登录页面即可\n        let ret = session.get(\"isOpen\");\n        if (ret == \"ok\") {\n          //vuex用户信息判断，如果不存在，则重新登录\n          MessageBox.alert(\"用户未登录,需要重新登录.\", \"错误\", {\n            confirmButtonText: \"确定\",\n            type: \"error\",\n          }).then(() => {\n            console.log(\"重新登录\");\n            //next(`/procmgr/login?redirect=${to.path}`);\n            next(`/login`);\n            NProgress.done();\n          });\n        } else {\n          next(`/login`);\n          NProgress.done();\n        }\n      } else {\n        //权限判断\n      }\n    }\n  }\n});\n\n```\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"localStorage、sessionStorage和cookie","url":"/2022/06/21/localStorage、sessionStorage和cookie/","content":"\n##  一、localStorage\n\nlocalStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的UI 上清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。\n\n## 二、sessionStorage\n\nsessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除。存 放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持。\n<!--more-->\n## 三、cookie\n\n\n\n### 优点\n\n具有极高的扩展性和可用性\n\n1. 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。\n2. 通过加密和安全传输技术，减少 cookie 被破解的可能性。\n3. 只有在 cookie 中存放不敏感的数据，即使被盗取也不会有很大的损失。\n4. 控制 cookie 的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就是一个过期的 cookie。\n\n### 缺点\n\n1.cookie 的长度和数量的限制。每个 domain 最多只能有 20 条 cookie，每个cookie 长度不能超过 4KB。\n否则会被截掉。\n2.安全性问题。如果 cookie 被人拦掉了，那个人就可以获取到所有 session 信息。加密的话也不起什么\n作用。\n3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若\n\n吧计数器保存在客户端，则起不到什么作用。\n\n4.`http请求` 时需要发送到服务端，增加了请求的数据量\n\n## 共同点\n\nlocalStorage、sessionStorage、Cookie 都是保存在浏览器端，且同源的\n\n## 区别\n\n1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 \n2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 \n3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 \n4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 \n5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 \n6、web Storage的api接口使用更方便\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"箭头函数和普通函数","url":"/2022/06/18/箭头函数和普通函数/","content":"\n## 一、箭头函数中this的指向不同\n\n箭头函数的this指向上层函数作用域的this对象，如果没有上层函数作用域，则指向顶部this（在浏览器中顶部this则是window）。普通函数的this指向该函数的调用者。\n  call, apply, bind会改变普通函数的this，但不会改变箭头函数的this\n\n```\nvar name = \"this1\";\nfunction wrap(){\n  this.name=\"this2\";\n  let func=() => {\n    console.log(this.name);\n  }\n  func();\n}\nlet en=new wrap();\n\n```\n\n<!--more-->\n\n## 二、外形不同\n\n箭头函数使用箭头定义，普通函数中没有\n\n```\n// 普通函数\nfunction func(){\n  // code\n}\n// 箭头函数\nlet func=()=>{\n  // code\n}\n\n```\n\n## 三、箭头函数都是匿名函数\n\n普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。\n\n```\n// 具名函数\nfunction func(){\n  // code\n}\n \n// 匿名函数\nlet func=function(){\n  // code\n}\n\n// 箭头函数全都是匿名函数\nlet func=()=>{\n  // code\n}\n\n```\n\n## 四、箭头函数不能用于构造函数，不能使用new\n\n普通函数可以用于构造函数，以此创建对象实例。\n\n```\nfunction Person(name,age){\n   this.name=name;\n   this.age=age;\n}\nlet admin=new Person(\"栤bong\",18);\nconsole.log(admin.name); //栤bong\nconsole.log(admin.age);  //18\n\n```\n\n## 五、其他区别\n\n- 普通函数的参数是arguments,而箭头函数的的是args\n- 箭头函数不具有prototype原型对象\n- 箭头函数不具有super\n- 箭头函数不具有new.target","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Vue路由","url":"/2022/06/16/Vue路由/","content":"\n## Vue路由\n\n路由模式有两种：history、hash，区别有以下：\n\n1.表现形式不同 \n\n​\thistory：http://localhost:8080/about\n\n​\thash：http://localhost:8080/#/about\n\n2.跳转请求\n\n​\thistory：http://localhost:8080/id ==>发送请求\n\n​\thash：不会发送请求\n<!--more-->\n\n3.打包后前端自测要使用hash，如果使用history会出现空白页面\n\n### Vue路由跳转\n\n1.声明式导航 ，在router-link中进行跳转\n\n2.编程式导航，通过点击事件，利用push/replace，可编写业务代码\n\n### 嵌套路由\n\n在路由内写children，继续创建路由\n\n```\n{\n    path: '/Notes',\n    name: 'Notes',\n    redirect: '/Notes/newFile',\n    component: function () {\n      return import('../views/noteMain.vue')\n    },\n    children: [\n      {\n        path: \"/Notes/newFile\",\n        name: \"myNotes\",\n        component: function () {\n          return import('@/components/newFile.vue')\n        }\n      }\n    ]\n  }\n```\n\n\n\n## Vue路径传值\n\nvue路径传值有两种，在网页路径显示参数的显式传值和不显示的隐式传值\n\n```\n1.显式\n\t传：this.$router.push({\n\t\tpath:'/about',\n\t\tquery:{\n\t\t\ta:1\n\t\t}\n\t})\n\t接： this.$route.query.a\n2.隐式\n\t传： this.$router.push({\n\t\tname:'About',\n\t\tparams:{\n\t\t\ta:1\n\t\t}\n\t})\n\t接：this.$route.params.a\n```\n\n# ","tags":["Vue"],"categories":["Vue"]},{"title":"原型和原型链","url":"/2022/06/13/原型和原型链/","content":"\n## 原型\n\n**原型**就是存储方法或属性的对象，可以解决对象共享属性和共享方法,。函数才有prototype属性。\n\n**prototype(原型)：**prototype是Function对象的一个属性，它定义了构造函数制造出的对象的公用祖先（属性和方法），可以继承该原型的属性和方法。原型也是对象。\n\n**__proto__（隐式原型）：**没个对象的__proto__属性指向自身构造函数的prototype。\n\n**constructor（构造器）：**返回对创建此对象的数组函数引用。\n<!--more-->\n## 原型链\n\n原型链是一种机制，指的是js中，每个对象都有一个属性__proto__，指向它的构造函数的原型对象。原型对象也是一个对象，因此也有__proto__属性指向原型对象的原型对象，这样一层层向上直到对象的原型对象为空（Object的原型对象Object.prototpye的属性__proto__为null）。\n\n原型链就是把原型串联起来，实现对象间的联系即继承的方法。\n\n可通过下面例子查看它们之间的关系\n\n```javascript\n\t\t\tfunction Person(){}\n\t\t\tvar p = new Person();\n\t\t\tconsole.log(p.__proto__)//打印出一个对象\n\t\t\tconsole.log(p.__proto__.constructor)//构造函数本身\n\t\t\tconsole.log(Person.prototype)\n\t\t\tconsole.log(Person.prototype.constructor)\n\t\t\tconsole.log(p.__proto__===Person.prototype)\n\t\t\tconsole.log(p.__proto__.constructor===Person.prototype.constructor)\n\t\t\t\n```\n\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Vue生命周期","url":"/2022/06/11/Vue生命周期/","content":"\n## 生命周期是什么？\n\n Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，称这是 Vue 的生命周期。\n\n## 各个生命周期作用\n<!--more-->\n\n| 生命周期      | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                       |\n| created       | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 |\n| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用           |\n| mounted       | el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子    |\n| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前              |\n| update        | 组件数据更新之后                                             |\n| activited     | keep-alive 专属，组件被激活时调用                            |\n| deactivated   | keep-alive 专属，组件被销毁时调用                            |\n| beforeDestory | 组件销毁前调用                                               |\n\n\n\n## keep-alive\n\nkeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ,有以下特性：\n\n1. 一般结合路由和动态组件一起使用，用于缓存组件\n2. 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 \n3. 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"闭包","url":"/2022/06/08/闭包/","content":"\n闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。\n\n## 闭包的用途\n\n​\t闭包最大的用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用后被自动清除。\n\n​\t在页面中写多个li标签，使用下面代码，点击li标签可知是第几个li标签\n<!--more-->\n\n```javascript\nvar lis = document.getElementsByTagName('li');\n\t\tfor(var i=0;i<lis.length;i++){\n\t\t\t(function(i){\n\t\t\t\tlis[i].onclick=function(){\n\t\t\t\t\talert(i);\n\t\t\t\t}\n\t\t\t})(i)\n\t\t}\t\n```\n\n## 闭包的缺陷\n\n​\t闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或变为null。\n\n```\nvar lis = document.getElementsByTagName('li');\n\t\tfor(var i=0;i<lis.length;i++){\n\t\t\t(function(i){\n\t\t\t\tlis[i].onclick=function(){\n\t\t\t\t\talert(i);\n\t\t\t\t}\n\t\t\t\t//手动清空变量\n\t\t\t\tlis[i]=null;\n\t\t\t})(i)\n\t\t}\n```\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"mysql","url":"/2022/04/11/mysql/","content":"## 数据库\n\nMySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。\n<!--more-->\n\n### 关系型数据库\n\n关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织\n\n#### 优点：\n\n1、易于维护：都是使用表结构，格式一致；\n2、使用方便：SQL语言通用，可用于复杂查询；\n3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。\n\n#### 缺点：\n\n1、读写性能比较差，尤其是海量数据的高效率读写；\n2、固定的表结构，灵活度稍欠；\n3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。\n\n\n### 非关系型数据库\n\n非关系型数据库(NoSQL)严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。\n\n#### 优点：\n\n1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。\n2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；\n3、高扩展性；\n4、成本低：nosql数据库部署简单，基本都是开源软件。\n\n#### 缺点：\n\n1、不提供sql支持，学习和使用成本较高；\n2、无事务处理；\n3、数据结构相对复杂，复杂查询方面稍欠。\n\n\n\n## 使用\n\n### 标准SQL语句\n\n 常见的操作有查询，新增，更新，删除，求和，排序等。\n\n查询语句：SELECT param FROM table WHERE condition 该语句可以理解为从 table 中查询出满足 condition 条件的字段 param。\n\n新增语句：INSERT INTO table （param1，param2，param3） VALUES （value1，value2，value3） 该语句可以理解为向table中的param1，param2，param3字段中分别插入value1，value2，value3。\n\n更新语句：UPDATE table SET param=new_value WHERE condition 该语句可以理解为将满足condition条件的字段param更新为 new_value 值。\n\n删除语句：DELETE FROM table WHERE condition 该语句可以理解为将满足condition条件的数据全部删除。\n\n去重查询：SELECT DISTINCT param FROM table WHERE condition 该语句可以理解为从表table中查询出满足条件condition的字段param，但是param中重复的值只能出现一次。\n\n排序查询：SELECT param FROM table WHERE condition ORDER BY param1该语句可以理解为从表table 中查询出满足condition条件的param，并且要按照param1升序的顺序进行排序。\n\n\n\n```sql\nCREATE DATABASE `smbms`;\n\nDROP TABLE IF EXISTS `smbms_address`;\nCREATE TABLE `smbms_address`  (\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',\n  `contact` VARCHAR(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '联系人姓名',\n  `addressDesc` VARCHAR(50) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '收货地址明细',\n  `postCode` VARCHAR(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '邮编',\n  `tel` VARCHAR(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '联系人电话',\n  `createdBy` BIGINT(20) NULL DEFAULT NULL COMMENT '创建者',\n  `creationDate` DATETIME NULL DEFAULT NULL COMMENT '创建时间',\n  `modifyBy` BIGINT(20) NULL DEFAULT NULL COMMENT '修改者',\n  `modifyDate` DATETIME NULL DEFAULT NULL COMMENT '修改时间',\n  `userId` BIGINT(20) NULL DEFAULT NULL COMMENT '用户ID',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = INNODB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = DYNAMIC;\n\nINSERT INTO `smbms_address` VALUES (1, '王丽', '北京市东城区东交民巷44号', '100010', '13678789999', 1, '2016-04-13 00:00:00', NULL, NULL, 1);\n\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"正则表达式","url":"/2022/03/05/正则表达式/","content":"\n# 正则表达式\n\n## 简介\n\n> ​\t正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为**regex**、**regexp**或**RE**），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。\n> ​\t正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。\n\n## 常用元字符\n<!--more-->\n| 字符    | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| \\       | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\\\' 匹配 \"\\\" 而 \"\\(\" 则匹配 \"(\"。 |\n| ^       | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $       | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| *       | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| +       | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| ?       | 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 。? 等价于 {0,1}。 |\n| .       | 匹配除换行符以外的任意字符                                   |\n| \\w      | 匹配字母或数字或下划线                                       |\n| \\s      | 匹配任意的空白符                                             |\n| \\d      | 匹配数字                                                     |\n| \\W      | 匹配非字母或数字或下划线                                     |\n| \\D      | 匹配非数字                                                   |\n| \\S      | 匹配非空白符                                                 |\n| [...]   | 匹配字符组中的字符                                           |\n| [^...]  | 匹配除了字符组中字符的所有字符                               |\n| .*      | 贪婪匹配                                                     |\n| **.*?** | 惰性匹配                                                     |\n\n## 作用\n\n使用正则表达式在字符串中搜索需要的字符。判断字符串是否正则表达式的过滤逻辑（称作“匹配”），从而获取我们需要的部分。\n\n正则表达式的特点是灵活性、逻辑性和功能性强大，可以迅速、极简单的方式达到字符串的复杂控制。可用于搜索、python爬虫筛选需要的数据。\n\n[点击测试正则表达式](https://c.runoob.com/front-end/854/) \n\n","tags":["正则表达式"],"categories":["Github"]},{"title":"Vuex","url":"/2022/02/07/Vuex/","content":"## 什么是Vuex？\n\n> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式 + 库**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## 安装\n\n```\nnpm install vuex --save\n//使用\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n<!--more-->\n\n### promise\n\nVuex 依赖Promise。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如es6-promise。在vue3x中\n\n```\n//安装\nnpm install es6-promise --save \n//需要添加在使用Vuex之前\nimport 'es6-promise/auto'\n```\n\n## 核心概率\n\nVuex 的核心由五部分组成：State、Getter、Mutation、Action 和 Module，简单的 Vuex，也至少会由 State 和 Mutation 构成。\n\n### state\n\n### mapState辅助函数\n\n当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性\n\n### Getter\n\n有时候，我们会发现 State 中的数据，并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求，这时我们可以使用Getter\n\n### Mutation\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数\n\n### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 提交的是 mutation，而不是直接变更状态。\n- Action 可以包含任意**异步**操作。\n\n### Module\n\n这个是项目比较复杂时使用，一般很多使用\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割","tags":["Vuex"],"categories":["Vuex"]},{"title":"Element Plus","url":"/2022/02/06/Element-Plus/","content":"> 基于 Vue 3，面向设计师和开发者的组件库。\n>\n> element终于发布新版本了，这让我们使用Vue3的时候更方便，以下是两个element对于vue的使用方法\n\n## 一、Element UI\n\n[Element UI官网](https://element.eleme.io/#/zh-CN) \n\n如果是Vue 2.x搭建的项目，使用elementUI如下\n\n```\nvue add element\n```\n<!--more-->\n完整引入，在main.js下写\n\n```js\nimport Vue from 'vue';\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\nimport App from './App.vue';\n\nVue.use(ElementUI);\n\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n});\n```\n\n之后在组件里寻找需要的功能\n\n## 二、Element Plus\n\n[Element Plus官网](https://element-plus.gitee.io/zh-CN/)\n\n如果是Vue3.x使用这个，在搭建好的项目了，下载\n\n```\n npm install element-plus --save\n```\n\n### 使用\n\n在main.js中写\n\n```js\nimport { createApp } from 'vue'\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\napp.use(ElementPlus)\napp.mount('#app')\n```\n\n\n\n","tags":["Vue","Element"],"categories":["Vue","Element"]},{"title":"TCP/IP协议","url":"/2022/01/26/让div水平垂直居中11/","content":"\n# TCP/IP协议\n\n## 什么是TCP/IP协议\n\n> TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。\n>\n> 在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。计算机使用者意识到，只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。\n>\n> 但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了\n<!--more-->\n## IP\n\nIP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。\n\n通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。\n\n当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。\n\nIP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。\n\n在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。\n\n每个计算机必须有一个 IP 地址才能够连入因特网。每个 IP 包必须有一个地址才能够发送到另一台计算机。网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。\n\n## TCP\n\nTCP 用于应用程序之间的通信。\n\n当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。\n\n这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。\n\nUDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。\n\n### TCP三次握手\n\n所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。\n\n### TCP四次挥手\n\n所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，\n\n\n\n## TCP/IP\n\nTCP/IP 意味着 TCP 和 IP 在一起协同工作。\n\nTCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。\n\nIP 负责计算机之间的通信。\n\nTCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。\n\nIP 负责将包发送至接受者。\n\n### TCP/IP协议分层\n\nTCP/IP协议族按照层次由上到下，层层包装。\n\n可搜索OSI 七层模型和TCP/IP四层模型更能直观了解\n\n**应用层**:\n 向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。\n\n**传输层**:\n 提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。\n\n**网络层** ：\n 负责相邻计算机之间的通信。其功能包括三方面。\n 一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。\n\n二、处理输入数据报：首先检查其合法性，然后进行寻径--假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。\n\n三、处理路径、流控、拥塞等问题。\n\n**网络接口层**：\n 这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。","tags":["TCP/IP协议"],"categories":["TCP/IP协议"]},{"title":"Git","url":"/2022/01/25/Git/","content":"## 一、Git文件的三种状态和工作模式\n\n### 1.状态\n\n使用Git操作文件时，文件的三种状态\n\n|       状态        |                             描述                             |\n| :---------------: | :----------------------------------------------------------: |\n| 已提交(committed) |             表示数据已经安全的保存在本地数据库中             |\n| 已修改(modified)  |            表示修改了文件，但还没有保存到数据库中            |\n|  已暂存(staged)   | 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 |\n<!--more-->\n### 2.工作模式\n\nGit项目的三个工作区域\n\n|  分类   |                             描述                             |\n| :-----: | :----------------------------------------------------------: |\n| 工作区  |                      自己本地创建的项目                      |\n| 暂存区  | Git版本库里存着很多东西，其中最重要的是称为stage(或者叫index)的暂存区，还有Git自动创建的第一个分支master，以及指向master的一个指针叫HEAD |\n| Git仓库 |  工作区有一个隐藏目录.git,这个不算是工作区，而是Git的版本库  |\n\n基本的Git工作流程如下：\n\n- 在工作区中修改文件\n- 对修改的文件进行快照，然后添加到暂存区\n- 提交更新，将保存在暂存区域的文件快照永久转储到Git仓库中 \n\n## 二、创建版本库并提交文件\n\n```c\ngit init 初始化本地仓库\ngit status 查看状态\ngit add . 添加文件,<path>是文件也可以是目录\ngit commit -m '注释' 提交添加的文件并备注说明\ngit remote add origin xxx  xxx是远程仓库地址，连接远程仓库\ngit push -u origin master 将本地仓库文件推送到远程仓库\n```\n\n## 三、文件操作\n\n### 1、查看\n\n```c\ngit log 查看变更日志\ngit branch 查看分支\ngit reflog 查看之前的修改操作\ngit ls-files 查看暂存区文件 \ngit log -5 --pretty=oneline 查看最近五次修改操作\n```\n\n### 2、删除\n\n```c\ngit rm 文件名.后缀 工作区和本地仓库的文件都删除\ngit remote rm origin 删除远程仓库\n```\n\n### 3、文件恢复\n\n如果已经把文件提交到本地仓库，却不小心误删了\n\n```c\ngit checkout -- 文件名.后缀 如果已经把文件提交到本地仓库，不小心误删了，可以从本地仓库把文件恢复到工作区\n```\n\n## 四、版本回退\n\n```c\ngit reset --hard HEAD^    //回退多少个版本就多少个^,或者~1,回退多少个版本数字就写多少个，或者 -hard 版本号    \n```\n\n","tags":["Github","Git"],"categories":["Github","Git"]},{"title":"使用jsDeliver+Github建图床","url":"/2022/01/24/使用jsDeliver-Github建图床/","content":"## 一、介绍\n\n### 1.什么是jsDlive\n\n> jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。\n\n### 2.为什么使用图床\n\n> 图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。\n>\n> Github使用的是cdn加速\n\n我们写博客或网站时，会使用到图片，把图片放到本地的话，可能会出现问题，还会影响网页加载速度，使用图床能很好解决这些问题。\n<!--more-->\n\n## 二、使用Github创建仓库\n\n### 1.创建Github仓库\n\n找到Repositories,点击new，写入仓库名，注意仓库要公开的，选择Public，然后创建\n\n### 2.将图片推送到仓库\n\n在本地文件夹使用Git Bash，与创建的Github仓库连接，放入图片\n\n```c\ngit add * //*代表当前目录所有文件\ngit commit -m \"写要提交的信息\"\ngit push //推送到远程仓库\n```\n\n## 三、使用jsDelive加载图片\n\n根据格式写出来的链接相对于一个外链，直接使用即可\n\n```c\nhttps://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径\n\n//例\nhttps://cdn.jsdelivr.net/gh/BinBK/mycdn/images/background2.png\n```\n\n\n","tags":["Github","jsDlive"],"categories":["Github","jsDlive"]},{"title":"IDEA的使用","url":"/2022/01/23/123/","content":"## 导入项目时出现的问题\n\n没有运行按钮，查看文件颜色不正确为橙色。\n<!--more-->\n1. 检查maven，jdk版本是否对应\n2. 选择File→Project Structure→Modules，查看是否为本地地址，如果不是，在Add Content Root中把项目叉掉，再点击+，选择项目\n3. 如果pom.xml文件为橙色，右键–>add as maven projec，下载依赖\n\n## 运行web项目\n\n在锤子图案旁边的Add Configuration，点击+，选择Tomcat的local，配置本地Tomcat地址，在Deployment中选择需要运行的项目\n\n## 快捷键\n\nShift+F10 \t运行\n\nShift+回车\t不影响当行，跳到下行\n\nAlt+Shift+↓\t快速复制当行\n\nCtrl+R\t\t\t快速替换\n\nCtrl+F\t\t\t快速查找\n\nCtrl+Alt+左右键\t回到上次光标所在","tags":["IDEA"],"categories":["IDEA"]},{"title":"使用网易云api","url":"/2021/10/28/使用网易云api/","content":"\n## 网址\n\n[网易云音乐 API](https://binaryify.github.io/NeteaseCloudMusicApi/#/)\n\n### 安装使用\n\n上面网址有说明\n先安装 他的东西，再加入他的文件夹 npm install\n再运行即可\n\n[参考](https://blog.csdn.net/lin13958756858/article/details/90906286)\n"},{"title":"axios使用","url":"/2021/10/19/axios使用/","content":"\n## axios\n\n### 直接使用\n\n一、\n安装 axios\nnpm install --save axios\n二、\n导入 axios\nimport axios from 'axios'\n三、使用\n<!--more-->\n\n\n```js\nmounted(){\nthis.$axios.get(\"网址\")\n.then(res => {\nconsole.log(res.data);\n})\n.catch(error =>{\nconsole.log(error);\n})\n}\n```\n\n### 跨域\n\n一、\n安装\n二、使用到的文件\nmain.js\nvue.config.js\napp.vue\n三、\n\n##### main.js\n```js\nimport axios from 'axios'\n\nVue.prototype.$axios = axios;\n```\n\n\n\n#### vue.config.js\n```js\nmodule.exports = {\ndevServer: {\nproxy: {\n'/te': {\n// 此处的写法，目的是为了 将 /api 替换成 https://www.baidu.com/\ntarget: 'http://apis.juhe.cn',\n// 允许跨域\nchangeOrigin: true,\nws: true,\npathRewrite: {\n'^/te': ''\n}\n}\n}\n}\n}\n\n```\n\n#### app.vue\n\n和上面一样，改前面的地址\n\n[跨域参考一](https://www.cnblogs.com/l-y-h/p/11815452.html)\n[中文文档](https://www.kancloud.cn/yunye/axios/234845)\n\n[可以直接连接的网络接口](http://www.iwenwiki.com/)\n\nq:\n拦截器，开发环境和生产环境怎么区分\n","tags":["axios"],"categories":["axios"]},{"title":"查看端口某个端口是否被占用","url":"/2021/10/15/查看端口某个端口是否被占用/","content":"\n> 启动应用时不能运行，有可能时要使用的端口被别的程序占用，但又不知道被谁占用，那我们就需要找出是什么程序并关闭\n<!-- more -->\n## 一、查找占用端口的PID\n\n打开cmd命令行窗口，输入命令：**netstat -ano**,就可以列出使用使用中的端口，可以看到以下显示，在本地地址中最后一串数字就是我们想要的端口，在这里查看是否被占用\n\n![image-端口展示](https://cdn.jsdelivr.net/gh/BinBK/myCdn/images/PID211015a.png)\n\n查看被占用端口对应的PID，输入命令：netstat -aon|findstr “数值”，输入端口可查到相关使用信息，输入PID可看到相关端口\n\n## 二、根据PID找到相关程序\n\n继续输入**tasklist|findstr** \"PID数值\"，查看是哪个进程或者程序占用了端口\n\n## 三、关闭相关程序\n\n打开任务管理器，找到相关程序并关闭\n![image-任务管理器](https://cdn.jsdelivr.net/gh/BinBK/myCdn/images/PID211015b.png)","tags":["计算机"],"categories":["计算机"]},{"title":"hexo加入图片","url":"/2021/10/14/hexo简单介绍/","content":"\n## 加入图片\n\n### 下载插件\n\n一、\nnpm install https://github.com/7ym0n/hexo-asset-image --save\n这是修改过的插件，因为版本问题用这个比较好\n二、\n配置\\_config.yml 里面的 post_asset_folder:false 这个选项设置为 true。\n<!--more-->\n三、\n\n使用\n![xxx](xxx/xxx.png)\n问题一：怎么解决让格式代码正常显示\n\n[具体网站](https://www.jianshu.com/p/3db6a61d3782)\n\n## 可参考博客\n\n[博客一](https://notes.iissnan.com/2015/something-about-next/)\n[博客二](http://51world.win/) 这个有点旧了，注意看时间\n\n## hexo 书写相关文章\n\n[网站一](https://www.jianshu.com/p/56d99a3049a5)\n","tags":["hexo"],"categories":["hexo"]},{"title":"让div水平垂直居中","url":"/2021/10/14/让div水平垂直居中/","content":"使用css让div盒子实现水平垂直居中的几种方法\n\n## 一、flex\n\n使用flex布局，在父元素上写，子元素将水平垂直居中\n\n```html\n#container{\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n}\n```\n<!--more-->\n\n\n## 二、使用定位\n\n准备\n\n```html\n<style type=\"text/css\">\n\nhtml,body{\n\theight:100%;  /*注意html不设置高度 body也就没有继承高度，就会随内容支撑高度*/\n\toverflow: hidden;  \n\tmargin:0;\n\tpadding: 0;\n}\n</style>\n\n```\n\n### 1.已知道宽高，绝对定位,margin减去div一半宽高\n\n```html\n#box{\n\tbackground: red;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\tmargin-left: -100px;\n\tmargin-top: -100px;\n}\n```\n\n### 2.div宽高未知，使用translate平移一半宽高\n\n```html\n#box {\n\tbackground: red;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\ttransform: translate(-50%,-50%);\n}\n```\n\n### 3.定位好，margin:auto\n\n```html\n#box {\n\tbackground: red;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\ttop: 0;\n\tbottom: 0;\n\tmargin: auto;\n}\n```\n\n","tags":["css"],"categories":["css"]},{"title":"Github的使用","url":"/2021/10/13/Github的使用/","content":"\n## 一、使用Github搜索项目\n\n> 最简单的是直接使用搜索框搜索项目，但这样搜索出来的项目多且乱，不知道使用那一个比较好，使用Github高级搜索语法能更快让我们找到想要的项目\n<!-- more -->\n### Github高级搜索语法\n\n#### 1.stars\n\n想要找到高质量的项目，可通过筛选star数找到多人收藏的。stars:>3000，直接在搜索的项目后面加空格写入即可找到star三千以上的项目。\n\n#### 2.pushed\n\n如果想找最近有更新的项目，可使用这个。pushed：>2022-1-1,即可找到2022年一月一号也后更新的项目\n\n#### 3.desciption\n\n搜索项目的简介。in:description 博客，即可找到简介有博客这个词的项目\n\n#### 4.language\n\n搜索项目的语言\n\n## 二、本地文件上传到Github仓库\n\n> 需要先配置SSH key。cd ~/. ssh #检查本机已存在的ssh密钥，如果提示：No such file or directory 说明你是第一次使用git，则需要配置。已经安装了node.js、npm、git\n\n在Repositories中新建一个仓库，在本地新建文件夹，点击进入后，打开Git Bash或cmd命名窗口\n\n初始化本地仓库\n\n```c\ngit init\n```\n\n将文件提交到暂存区, . 是选择所有文件\n\n```c\ngit add .\ngit commit -m \"写提交文件的说明\"\ngit branch -M main 第一次创建需要写\ngit remoted aa origin xxxx 写仓库的地址，第一次提交需要写\ngit push -u origin main\t提交到远程仓库    \n```\n\n## 三、将Github项目下载到本地\n\n有两个办法，一、直接下载压缩包，二、git clone 地址，下载到本地\n","tags":["Github"],"categories":["Github"]},{"title":"Hello World","url":"/2021/10/12/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]